### 冒泡排序

遍历整个数组，比较相邻的俩个数据项，如果左边的数据项大于右边的数据项则交换俩个数据项，否则不交换，以此来找到全局最大的数据项。

再依次比较剩下的数据项，直到数据有序。

- a => b => c => d，确定d是最大的
- a => b => c，确定c是最大的
- b => b，确定b是最大的
- 比较完毕

时间复杂度是$O(N^2)$，额外空间复杂度是$O(1)$，实现可以做到稳定性。



### 选择排序

遍历整个数组选出最小的数据项放在数组第一位索引上，然后遍历剩余的数据项选出最小的数据项放在数组第二位索引上，重复此过程直到数组有序。

例如有数组：A、B、C、D、E，需要在以下数据项中查找最小的数据项：

- A、B、C、D、E    => N
- B、C、D、E          => N-1
- C、D、E                => 3
- D、E                      => 2

常数操作有$(N-1) + (N-2) + ... + 2 + 1$，这是一个等差数列，所以时间复杂度是$O(N^2)$，额外空间复杂度是$O(1)$



### 插入排序

插入排序是将一个无序的数组插入到一个有序数组中的过程。

假定数组第一个数据项作为有序的一部分，剩余数据项作为无序的部分。排序过程就是将无序数据项中的每个数插入到有序部分数据项中合适的位置。

例如数据项A作为有序的部分，比较步骤有：

- B与A比较
- C与A/B比较
- D与A/B/C比较
- E与A/B/C/E比较

在最好情况下时间复杂度为$O(N)$，最坏情况下是$O(N^2)$，平均情况下时间复杂度也是$O(N^2)$



### 递归

递归是把一个大规模的问题分解成若干个小规模问题来进行处理，无论是处理大规模还是处理小规模，处理问题的方法是一致的。

- basecase

  在将问题划分成子问题时，当子问题达到一个规模时将停止划分。

  如果递归没有basecase将会造成内存溢出。

```php
function getMax($array, $left, $right) {
    if ($left == $right) {
        return $array[$left];
    }
    $mid = ($left + $right) / 2; 
    $maxLeft = $this->getMax($array, $left, $mid);
    $maxRight = $this->getMax($array, $mid + 1, $right);
    return $maxLeft > $maxRight ? $maxLeft : $maxRight;
}
// 时间复杂度是O(N)，空间复杂度O(logN)
```

在工程上递归是通过系统栈来实现的。一个函数在调用时会将当前环境信息（当前代码行）和实参等信息压入到栈中，如果在调用过程中发生递归，那么子过程也会将当前环境信息压入栈中，直到子问题碰到basecase时停止。

在碰到basecase时会将子过程从栈中弹出，回到发生递归之前的场景继续执行代码。



### master公式

如果一个算法的时间复杂度公式为：
$$
T(n) = aT(n/b) + O(N^d)
$$
即样本量是b分之n的情况下，发生了a次调用，除去递归行为剩下的复杂度是$O(N)$的d次方，对于这种公式，master公式可以直接计算出复杂度。

具体有3种情况：

- $log_{b}a>b$ ，时间复杂度是$O(N^{log_{b}a})$
- $d>log_{b}a$，时间复杂度是$O(N^{d})$
- $d=log_{b}a$，时间复杂度是$O(N^{d} * logN)$



案例：归并排序时间复杂度分析

空间如果整个算法复杂度是$T(N)$，N是样本量，在实现中将问题划对半的划分成俩个部分来解决，所以左部分的时间复杂度是$T(N/2)$，右部分时间复杂度是$T(N/2)$，同时在合并这俩个部分的时间复杂度是$O(N)$，得到公式：
$$
T(N) = 2T(N/2) + O(N)
$$
a=2，b=2，d=1，代入公式$log_ba$是$log_22$的值是1，所以是第三种情况，时间复杂度是$logN*N$。





### 归并排序

归并排序是一个递归过程。假设有N个数据项，问题的规模可以用函数$f(N)$来表示，将其划分为$f(0-N/2)$和$f(N/2+1-N)$俩个部分并分别使其有序，然后将这俩部分有序的数据项进行合并。

$f(0 -N/2)$是子规模，它也是一直进行划分并排序，直到问题的规模不可划分时停止，整个递归过程中是从顶向下进行划分，直到问题规模不可划分时，再从底向上过程中进行合并的过程。

- 时间复杂度

  将复杂度抽象成$T(N)$，递归的对半划分会产生$T(N/2)$俩个规模的节点(子问题)，一直对半的划分下去直到该规模为1时停止划分。

  如果将其抽象成一棵树，树的高度是$logN+1$，节点数（子问题数量）是$2N-1$，每层节点在合并排序过程中进行N次常数操作的比较，所以时间复杂度是$N*logN$。

  注：+1是树的最后一层，即递归的basecase，所以最后一层有N个叶子节点。

- 空间复杂度

  在外排序过程中，将俩部分数据项合并为一个有序的数组，代码申请了一个长度N的辅助数组，所以空间复杂度是$O(N)$




### partition

经典快速排序中需要先理解partition，即根据一个数，把数组中小于等于该数字的划分到左边，把大于该数字的划分到数组的右边。

解决：

- 可以定义一个概念上的小于等于区域，把小于等于该数字的数据项划分给它。我们通过一个变量less来实现，它指向了该逻辑区域的最右边，假定数组的最左边界为L，在开始时该变量的值等于L-1。

- 然后遍历数组比较每个数据项，如果数据项小于等于要比较的数，那么将该数据项与less变量（小于等于区域）的下一个位置上的数据项进行交换，同时less+1（小于等于区域往右扩展一位）继续比较下一个数；如果数据项大于要比较的数，则比较下一个数。

- 按照上述流程遍完整个数组就可以达到partition的目的。

```c
function partition($array, $left, $right){
    $less = $left - 1;
    for ($i = $left, $i <= $right, $i++) {
        if ($array[$i] <= $array[$right]) {
            swap($array, ++$less, $i);
        }
    }
    return $less;
}
```



### 荷兰国旗问题

假定数组的最右边项作为比较的数，将数组中小于该数的数据项划分到左边，等于的划分到中间，大于的划分到右边。

解决：

- 定义一个小于区域less用于划分小于的数据项，默认指向数组左边界的上一个指针；定义一个大于区域more用于划分大于的数据项，默认指向数组的右边界。

- 遍历数组比较每个数据项，如果当前数据项小于比较的数，将当前数据项与小于区域的下一个指针进行交换，同时小于区域向右扩展一位（less+1）继续比较下一个数据项；

  如果当前数据项等于比较的数则直接比较下一个数据项；

  如果当前数据项大于比较的数，将当前数据项与大于区域的前一个指针进行交换（more-1），同时向左扩展一位，然后继续比较当前数据项。

- 按照上述流程依次比较，直到当前数据项的指针与大于区域的指针相遇。

```c
function partition($array, $left, $right) {
    $less = $left - 1;
    $more = $right;
    
    for ($i = $left; $i < $right; $i++) {
        if ($array[$i] < $array[$right]) {
            swap($array, ++$less, $i);
        } else if ($array[$i] > $array[$right]) {
            swap($array, --$more, $i);
        }
    }
    
    swap($array, $more, $right);
    return [$less + 1, $more];
}
```



### 快速排序

经典快速排序是根据数组最右边的数进行比较，将小于该比较的数划分到左边，将大于比较的数划分到右边。

在将数据划分成俩部分后，分别对这俩个部分进行递归处理，继续进行数据的大小划分，以此来完成排序的过程。


- 时间复杂度

  快排的时间复杂度依赖于划分值，如果划分值打偏了，划分出来的小于区域和大于区域的数不够平均，算法的代价就会变高。

  如果划分值过大，例如：1,2,3,4,5,6,7。如果每次选取最后一个数作为划分值，会导致算法经过N-1次的划分排序过程，第1次划分有N-1次比较，第2次划分N-2次比较，算法的过程是一个等差数列，时间复杂度是$O(N^2)$。

  如果每次选取的划分值所划分的俩侧数据项很平均，那么快排的问题规模是：
  $$
  T(N) = 2T(N/2) + O(N)
  $$
  时间复杂度变为$O(lngN*N)$。

  所以快速排序在工程上选取划分数值时，会随机的去选择该数值，这样最差与最好情况的划分是一个概率的事件，通过概率来求一个总共概率的时间复杂度，是一个长期期望。



- 空间复杂度

  空间复杂度是$O(logN)$。

  在由顶向下递归划分过程中，每次需要一个辅助变量来保存划分点，该变量在递归结束后会进行回收，是可以复用的，因此求的是递归的深度。理想情况下每次都是居中划分，所以时间复杂度认为是$O(logN)$。

  与归并排序不同，归并排序是先由顶部到达底部，再由底部逐层向上排序，递归函数合并的过程中使用到N个长度的辅助数组，在结束递归后该空间就释放掉了，所以归并排序的空间复杂度是$O(N)$

注1：快排的常数项操作很低且长期期望的时间概率好，工程上表现很优秀。

注2：随机划分值，L + (int)Math.random() * (R-L+1)



### 堆排序

堆排序是为了理解堆这个数据结构的。

堆是一个完全二叉树结构，这棵树在生成过程中总是满二叉树结构，即树的每一层节点要么是满的，没满的层的节点一定是从左往右填满的。



落地结构是一个数组结构，通过下标变化来将数组转成一颗完全二叉树。

假设节点对应的下标为i，它的左节点等于$2 * i + 1$，它的右节点等于$2 * i + 2$。一个节点的父节点等于$(i - 1) / 2$。

堆根据每颗子树跟节点的不同，可以分为大根堆和小根堆。大根堆是指在整个堆中，每一颗子树的头节点都是这颗子树中的最大值。小根堆也是相同的代理。



建立大根堆：

- 遍历整个数组，依次比较每个数据项。
- 判断该数据项是否在整颗子树中是最大的值，因此需要与该数据项的父节点比较，如果大于父节点则交换俩个节点的位置。
- 将交换后的父节点作为当前数据项，重复此过程依次向上进行比较，直到到达这颗子树的根节点比较完毕或者小于它的父节点则停止比较。
- 一个数据项向上比较完毕后则比较下一个数据项，直到数组越界。

大根堆的建立是每个节点向上比较的过程，每个节点建立的时间复杂度是堆高度的大小，第一个节点是$O(1)$，第二个节点是$log$1，整个堆建立的复杂度是$log1 + log2 + ... + logN$。在数学上是能收敛为$O(N)$的。

```c
function buildHeap($array) {
    for($i = 0; $i < count($array); $i++) {
        $this->heapInsert($array, $i);
    }
}

function heapInsert($array, $i) {
    $p = ($i - 1) / 2;
    while ($p >= 0) {
        if ($array[$i] > $array[$p]) {
            swap($array, $p, $i);
            $i = $p;
            $p = ($i - 1) /2;
        } else {
            break;
        }
    }
}

function heapInsert($array, $i) {
    while ($array[$i] > $array[($i - 1) / 2]) {
        swap($array, $i, ($i - 1) / 2);
        $i = ($i - 1) / 2;
    }
}
```



弹出一个根节点

- 将根节点与最后一个节点进行交换，同时将堆节点 - 1。可以通过一个变量Size指向数组的最右数据项的下标，意味要处理的堆节点数量。
- 将当前根节点与它的子节点比较，让最大的子节点与父节点进行交换，如果没有子节点大于它则停止比较的过程。
- 将交换后的子节点作为要比较的数据项，与它的子节点进行比较，重复此过程直到没有叶子节点。
- 比较完毕后，交换后的根节点就被插入到合适的位置了。

堆是一颗完全二叉树，弹出一个根节点的时间复杂度是$O(logN)$，N是堆节点数量。

```c
// size是堆的大小
function pop() {
    swap($array, 0, $size - 1);
    $this->heapify($array, 0, $size);
    return $array[$size--];
}

function heapify($array, $index, $heapSize) {
    $left = $index * 2 + 1;
    while ($left < $heapSize) {
        $largest = $left + 1 < $heapSize && $array[$left + 1] > $array[$left] ? $left + 1; $left;
        $largest = $array[$index] < $array[$largest] ? $largest : $index;
        
        if ($index == $largest)
            break;
        
        swap($array, $index, $largest);
        $index = $largest;
        $left = $index * 2 + 1;
    }
}
```





### 桶排序

桶排序是一种基于数据状况的排序，而非基础比较的排序。

假设有1亿个数据项，每个数据项值的范围在0至200之间，也就是有201个数；桶排序会先创建一个长度是201个数组，数组中每个位置都是容器，下标大小对应数字大小，存储时是存储数字出现的次数，即词频。

例如容器1只存储数值为1的数据项的出现的次数，遍历所有数据项，将值填到容器对应的位置，读取时按照容器顺序依次输出，同时输出每个数的出现的频率，这个是桶排序的核心思想。

- 复杂度分析

  时间复杂度是$O(N)$，空间复杂度是$O(N)$

- 实际工程使用桶排序比较少，因为需要记录数据状态，如果数据不是数值的话将会很麻烦。

基于桶排序思想的排序有：

- 计数排序：桶只统计每个数据项的词频而不是装具体的值
- 基数排序



### 基数排序

基于桶排序，只不过所申请的桶支持更大的范围。

基数排序并非单纯的用数组的长度来表示桶的数据范围，在确定了数据大小范围之后，每个桶代表的是一段范围的数字。



### 排序稳定性

一个无序数组经过排序后，相同数据项的原有次序不会发生变化，这个是排序的稳定性。

例如数组...2...2...2，数组中有多个2，在经过排序后这些2的原有次序是不变的，这种排序就是稳定性的排序。



### 题目

- 最小数求和，求数组中每一个数据项的左边比它小的数的和，再求所有数据项的最小数之和的累加。

- 求一个数组中有多少对降序对。

- 一个无序的数组，如果排序之后，相邻俩数的最大差值是多少，请返回给我？要求时间复杂度为O(N)

  1. 寻找无序数组中的最小值和最大值，确定数值的范围；
  2. 准备N+1个桶，将数值的范围平均的分割在每个桶上，即每个桶表示数值的区间是平均且连续性的；
  3. 将无序数组中每个数据项装到对应的桶中，由于N个数据项装到N+1个桶中，必将产生至少一个空桶，所以桶内会出现最大差值的可能性就被否定了，因为空桶的后一个非空桶的最小值 减去 空桶的前一个非空桶的最大值一定 大于 桶内的差值。
  4. 只查看每个非空桶，看后一个非空桶的最小值 减 前一个非空桶的最大值形成的差值，这些差值中间最大的就是答案。

  N个数字划分到N+1个桶里面，为什么会出现空桶？

  如何将数字放到桶里面？