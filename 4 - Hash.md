### 哈希函数

哈希函数又叫离散函数，它具有以下特点：

- 可接受的输入域是无穷的，返回的输出域是有限的

- 相同的输入域一定会返回相同的输出域

- 碰撞性：虽然输入域是无穷的，但是输出域是有限的，所以会导致不同的输入域对应同一个输出域

- 离散性

  假定输入域无穷大，输出域是S；在输入域无穷大的情况下得到整个输出域S，各个输入域在整个输出域S上是平均分布的

  假定输出域S是0、1、2，输入域是0至99共100个数，哈希函数能够把这100个数均匀分布这3个输出域上，这便是哈希函数的离散性。

  将输入域S模以M，输入域的各个元素也是平均分布在0 - M-1之间的。

哈希函数的作用：相似规律的输入，哈希函数能够将其打乱；一个哈希函数的离散性越好，该哈希函数的性能越优良。



### 哈希表

哈希表是使用哈希函数实现的一个含有键值对的数据结构，它一般提供俩个API：

- 通过key获取对应的值
- 添加一对键值对



落地结构：

- 我们可以初始化一个size大小的数组，每个元素都是一个链表。
- 然后将key哈细化并模以数组的大小，因为哈希函数的散列型，取模的结果是会平均分布在0到size-1之间的。
- 将取模的结果作为下标，使用下标元素的链表添加键值对元素，这便是添加元素的过程。
- 通过key获取对应的值也是一样道理，将key哈细化，找到下标所在的链表，遍历整个链表寻找到key，取出它的值即可。



关于扩容：

由于哈希函数的碰撞性，因此是有可能会有多个key添加到同个下标元素的链表中的，由于哈希函数的散列性，可以认为所有元素的链表长度大致都是相同长度的。

我们所要避免的是链表过长，导致时间复杂度增加，所以需要在链表达到一定长度的时候，对整个哈希表进行扩容。

扩容的策略? 后续实现的时候再考虑。



### 优化key的下标计算

> return k & (length-1)

一般计算key的下标是通过哈细化后的值去模以数组的长度，取模运算的性能比较低，因此可以利用上面的表达式来进行优化。

在该表达式中，k是键哈细化后的值，length是数组的长度，该值是2的幂次方。



哈希函数的散列特性会使输出值（哈希code）平均分布在输出域上，输出域可以理解为哈希函数的最小输出值和最大输出值的区间。

HashMap本质是通过数组来存储key的，一般计算数组的索引会使用哈希code与数组的长度进行取模运算，以此达到平均分布在数组中，
但是取模运算的计算成本比较高，因此java在计算key的索引时进行了优化。

java使数组的长度为2的幂次方，key的索引是哈希code与2的幂次方-1进行按位与运算的值，例如数组数组长度是2^4即16，16-1的二进制是1111 1111，哈希code的低八位可能是在0000 0000 至 1111 1111之间（散列特性），因此按位与运算后索引是平均分布在数组上的。

如果数组的长度不是2的幂次方，例如数组的长度是15，15-1的二进制是：1111 1110，低位上的下标为0所代表的桶将会一直是空桶，因为按位与计算后永远不会产生为1的数，所以类似0000 0001、0000 0011、0000 0111将无法使用，这样数组的使用空间就减少了，碰撞的概率就增加了，无疑降低了HashMap的性能。