### 位图

位图不是图，而是一个bit位的大数组。

每个bit位可以存储某种状态，值非0即1，由于使用bit位来存储数据，因此可以大大节省存储空间。



### 落地结构

BitMap是从左往右，从0开始标记每个bit位的。

它的落地结构可以是一个int数组，也可以是一个byte数组，数据类型取决于需求，例如：

```c
int array[100];
```

定义一个int型的数组，长度是100，由于int型是4个字节32位，每个元素都能代表32个bit位，所以array数组能够表示的bit位大小是100*32，即3200个bit位。

给定bit数组的最大长度是m，最低位是0，最高位是m-1，



```
在概念上，bit数组的位从0开始从左往右开始计算的bit位的，也就是说在setbit()时是从左往右数的，例如setbit(100, 1)，从0开始从左往右数第100个位就是要设置的bit位。

然后在实际存储中，确定要插入的索引元素后，在设置bit位时，是从右往左数来设置bit位的，例如：0000 0000，要设置偏移量是5的位为1，则从右往左从0开始计数，第5个位是1，即0010 0000
```



关于字节序
	一个数表现为二进制，最左边的数据位是高位字节，最右边的数据位是低位字节，而内存地址是从低位地址到高位地址增加的。 

​	大端序是高位字节存储到低位地址，小端序是高位字节存储到高位地址。

​	1个内存地址对应1个字节数据?



setbit(offset, value)

根据偏移量设置指定bit位的值，最低位是0，从左往右开始计算。

假设偏移量为s，bit数组是以int型数组来实现，要操作的元素索引是floor(s/32)，该元素要操作的位是s%32



getbit(offset)





