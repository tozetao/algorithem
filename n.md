#### 空间复杂度

一般说空间复杂度指的是额外空间复杂度，输入和输出的数据结构是不算在额外空间中的。

为了支持算法的流程需要使用多少辅助空间才能完成该算法的空间叫做额外空间，也就是所说的空间复杂度。

- 案例分析

  问题：有一个数组是1,2,3,5,7，左半区是1,2,3，右边区是5,7，要求交换左右俩个区间的数据，交换后的结果为5,7,1,2,3.

  正常解：按照正常的做法申请俩个区间大小的数组，分别存储左右区间的数据，先输出右边区的数据，再输出左半区的数据，因为开辟了N个长度的数据空间，所以该方法的空间复杂度是O(N)；

  优解：先交换左半区的数据，再交换右半区的数据，最后交换整个数组的数据项，该解法的额外空间复杂度是O(1)，时间复杂度是O(N)


- 算法的最优解：一个算法的最优解指的是先满足时间复杂度最优的情况下，再满足空间复杂度最优解。



#### 冒泡排序

```php
function BubbleSort($array){
    if(empty($array))
        return false;

    $length = count($array);
    for($i=$length-2; $i>=0; $i--){
        for($j=0; $j<=$i; $j++){
            if($array[$j] > $array[$j+1]){
                swap($array, $j, $j+1);
            }
        }
    }

    return $array;
}

function swap(&$array, $l, $r){
    $temp = $array[$l];
    $array[$l] = $array[$r];
    $array[$r] = $temp;
}
```

俩俩比较俩个数据项，如果左边的数据项大于右边的数据项则交换俩个数据项，遍历整个数组后将会把数组中最大的数据项交换到数组尾部，再俩俩比较剩余的数据项，重复此过程直到数组有序。

时间复杂度是O(N^2)，额外空间复杂度是O(1)，实现可以做到稳定性。



#### 选择排序

遍历整个数组选出最小的数据项放在数组第一位索引上，之后遍历剩余的数据项选出最小的数据项放在数组第二位索引上，重复此过程直到数组有序。

例如有数组：A、B、C、D、E，需要在以下数据项中查找最小的数据项：

- A、B、C、D、E    => N
- B、C、D、E          => N-1
- C、D、E                => 3
- D、E                      => 2

常数操作有2+3+...+(N-1)+N，这是一个等差数列，所以时间复杂度是O(N^2)，额外空间复杂度是O(1)



#### 插入排序

插入排序是将一个无序的数组插入到一个有序数组中的过程。

假设数组：A/B/C/D/E，将A数据项抽出来假定为一个有序的临时数组(只有一个数据项，肯定是有序的)，将剩下的数据项分别正确插入到有序的临时数组中。

比较插入的步骤有：

- B与A比较
- C与A/B比较
- D与A/B/C比较
- E与A/B/C/E比较

在最好情况下时间复杂度为O(N)，最坏情况下是O(N^2)，平均情况下时间复杂度也是O(N^2)



#### 归并排序

归并排序是一个划分的过程，假设有N个数据项，有函数f(N)，将其划分为f(0-N/2)和f(N/2-N)俩个部分进行内排序，再将俩部分有序的数据项进行合并。

具体递归过程中是从顶向下进行划分，在数据项只有一个时则停止，再从底向上过程中进行合并。

- 复杂度分析

  将N个数据项对半的划分这个过程是可以抽象成一棵树的，每次对半划分将有俩个节点，这里的节点并不是具体的数据，而是内排序的一个流程。

  那么这棵树的高度是logN+1，节点数是2N-1个节点；LogN+1的1是最后一层树的叶子节点，即递归的basecase，也就是只剩下一个数据项时停止递归。

  由于有LogN+1层节点，每层节点在外排序合并的过程中进行了N次比较，所以时间复杂度是logN^2，又因为在合并过程中每层节点申请了N个数组长度的空间，所以额外空间复杂度是logN^2。

  结论：时间复杂度是O(logN^2)，额外空间复杂度是O(logN^2)。

- 代码实现

  ```php

  ```

  ​