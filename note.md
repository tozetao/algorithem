
### 堆排序
堆结构是一颗完全二叉树结构，完全二叉树指的是一个父节点只有左节点和右节点，
并且每一层节点都是从左往右填满或者在填满的路上。

堆结构落地时是用一个数据结构来表示完全二叉树结构，
一个父节点i(i是索引位置)，左节点是2*i+1，右节点是2*i+2，相对的一个子节点i，它的父节点是(i-1)/2


- 建立一个大根堆
    整棵树的最大值是根节点，每颗子树的最大值都是这颗子树的根节点。

- heapInsert
    子节点向上比较

- heapify
    父节点向下比较，父节点与子节点最大值的节点交换，如果父节点小于子节点，则遍历结束。

- 复杂度
    建立堆的过程中，第一个节点的代价是log1，第二个节点的代价是log2，第n个节点的代价是logN，
    如果有n个节点，总代价为log1+log2+...+logN，(1+2)/2*n/2，logN^2 = N，所以建立大根堆的过程复杂度是O(N)。

    而在堆排序中，将第一个节点与最后一个节点交换，复杂度是O(1)，交换完后根节点向下调整的过程复杂度是O(logN)，


    完全二叉树的节点为n，它的高度是logN，所以在对堆中某个节点无论是向上或向下调整时，
    时间复杂度都为logN，即走树的高度。


### 桶排序
    基于数据状况的一种排序，而非基础比较的排序。

    假设有1亿个数据项，这些数据项都是数值类型，值在0-200范围内，也就是有201个数。
    我们可以通过创建201个容器，每个容器都存储其对应的值，例如容器1只存储数值为1的数据项，遍历所有数据项，将值填到对应的容器，读取时按照容器顺序依次取出数据项即可，这个是桶排序的核心思想。

    时间复杂度是O(N)，额外空间复杂度是O(N)，工程上使用较少，基于桶排序思想的有基数排序，计数排序。

- 计数排序
    针对上面的题目，准备一个201长度的help数组，并将其初始化为0，help数组下标对应要排序的数据项的值。
    在排序遍历数据项时，如果help数组下标和数据项值相等，则help数组下标中的值++，这样统计每个数据项出现的次数，可以节省空间。

- 基数排序
    基数排序与基数排序的思路是一样的，只不过其能支持更大的范围。

- 问题：如果有n个数，数的大小范围很大，是long long类型的，求相邻最俩个数的最大差值，要求时间复杂度是O(N)
    1. 数据在有序的情况下，俩俩比较才能求出最大差值
    2. 从无序到有序下，普通排序算法时间复杂度不满足要求，使用数值范围的桶排序也不满足要求，需要使用桶排序的思想来改进算法。

### 排序的稳定性
    原始序列中， 无序 => 有序

    无序数组中值相同的东西，在排成有序之后，相对次序能够保持不变，叫做稳定性。
    例如数据项：x x 3 x 3 x 3，在经过排序后，每个3的原本的次序不变，第一个3在左边，
    第二个3在中间，第三个3在右边。

    冒泡排序、插入排序、可以做到稳定性，

    归并排序可以做到稳定性，在归并过程中实现稳定性。

    选择排序/快速排序无法做到稳定性