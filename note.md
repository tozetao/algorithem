

- 荷兰国旗问题
问题：
    假设有一个数组，以最后一个数组作为中位数，请将小于中位数的数据项放在左边，
    大于中位数的数据项放在右边，等于中位数的数据项放在中间，因为荷兰国旗有3种颜色，
    所以该问题叫做荷兰国旗问题。

解答：
    定义left指针，指向起始数据项的上一个位置，用于表示以划分的左半部分，
    定义right之战，指向最后一个数据项位置，表示以划分的右半部分区域。

    中位数为最后一个数据项，遍历数据项列表，将每个数据项与中位数比较，
    如果小于中位数的，将该数据项与left指针的下一个位置数据项交换，同时left指针++，
    如果等于中位数的，遍历下一个数据项，
    如果大于中位数的，将该数据项与right指针的上一个位置数据项交换，同时right指针++，
    对于大于中位数的比较，循环的指针不会走向下一个数据项而是不变，使用大于中位数交换后的数据项再与中位数继续上述比较。

    一直进行上述的比较，当循环的指针碰到right指针的时候，循环结束，
    同时将数据项最后一个数与right指针最边的数进行交换(最后一个数是中位数)。

- 快速排序便是在中位数划分基础上进行的，递归的对一组数据进行中位数划分，直到碰到basecase。

- 快排的最差情况

    如果使用经典快速排序，每次都是使用最后一个数据项来进行中位数划分，
    在对一个从小到大有序的数据项排序时，时间复杂度将会达到O(N^2)，
    因为中位数不够平衡，导致算法进行了N次partition()排序，所以是N*N.

    例如1 2 3 4 5 6 7，倒叙的数据也是相同的道理。

    当最右的划分值导致左右划分不够平均的时候，算法的代价就会变得很高。
    所以经典的快速排序会随机选择划分值，这样碰到最差和最好情况是一个概率的值，
    算法过程的时间复杂度就是一个概率事件，

    通过随机在用概率来求一个总的概率的时间复杂度，是一个长期的期望。

    尽量满足T(N) = 2T(N/2) + O(N)公式

    最好情况
    最差情况
    长期期望

- 空间复杂度
    归并排序的空间复杂度是O(N)，因为在合并数据的时候中，需要一个辅助数据将左右俩边的数据拷贝进去再赋值回去。

    快速排序的空间复杂度是O(logN)，在使用中位数划分后，我们需要一个值在保存断点线，也就是划分好数据后
    左右俩部分数据的交点，这样才能继续递归的划分下去。

    假设中位数划分的很平均，断点线总是在中部位置，那么N个数据会有logN个断点位置，所以空间复杂度是logN，
    当然最差的情况是O(N)，即中位数划分的不够平均，划分的数据要么都在左边要么都在右边，所以需要划分N次

### 堆排序
堆结构是一颗完全二叉树结构，完全二叉树指的是一个父节点只有左节点和右节点，
并且每一层节点都是从左往右填满或者在填满的路上。

堆结构落地时是用一个数据结构来表示完全二叉树结构，
一个父节点i(i是索引位置)，左节点是2*i+1，右节点是2*i+2，相对的一个子节点i，它的父节点是(i-1)/2


- 建立一个大根堆
    整棵树的最大值是根节点，每颗子树的最大值都是这颗子树的根节点。

- heapInsert
    子节点向上比较

- heapify
    父节点向下比较，父节点与子节点最大值的节点交换，如果父节点小于子节点，则遍历结束。

- 复杂度
    建立堆的过程中，第一个节点的代价是log1，第二个节点的代价是log2，第n个节点的代价是logN，
    如果有n个节点，总代价为log1+log2+...+logN，(1+2)/2*n/2，logN^2 = N，所以建立大根堆的过程复杂度是O(N)。

    而在堆排序中，将第一个节点与最后一个节点交换，复杂度是O(1)，交换完后根节点向下调整的过程复杂度是O(logN)，


    完全二叉树的节点为n，它的高度是logN，所以在对堆中某个节点无论是向上或向下调整时，
    时间复杂度都为logN，即走树的高度。


### 桶排序
    基于数据状况的一种排序，而非基础比较的排序。

    假设有1亿个数据项，这些数据项都是数值类型，值在0-200范围内，也就是有201个数。
    我们可以通过创建201个容器，每个容器都存储其对应的值，例如容器1只存储数值为1的数据项，遍历所有数据项，将值填到对应的容器，读取时按照容器顺序依次取出数据项即可，这个是桶排序的核心思想。

    时间复杂度是O(N)，额外空间复杂度是O(N)，工程上使用较少，基于桶排序思想的有基数排序，计数排序。

- 计数排序
    针对上面的题目，准备一个201长度的help数组，并将其初始化为0，help数组下标对应要排序的数据项的值。
    在排序遍历数据项时，如果help数组下标和数据项值相等，则help数组下标中的值++，这样统计每个数据项出现的次数，可以节省空间。

- 基数排序
    基数排序与基数排序的思路是一样的，只不过其能支持更大的范围。

- 问题：如果有n个数，数的大小范围很大，是long long类型的，求相邻最俩个数的最大差值，要求时间复杂度是O(N)
    1. 数据在有序的情况下，俩俩比较才能求出最大差值
    2. 从无序到有序下，普通排序算法时间复杂度不满足要求，使用数值范围的桶排序也不满足要求，需要使用桶排序的思想来改进算法。

### 排序的稳定性
    原始序列中， 无序 => 有序

    无序数组中值相同的东西，在排成有序之后，相对次序能够保持不变，叫做稳定性。
    例如数据项：x x 3 x 3 x 3，在经过排序后，每个3的原本的次序不变，第一个3在左边，
    第二个3在中间，第三个3在右边。

    冒泡排序、插入排序、可以做到稳定性，

    归并排序可以做到稳定性，在归并过程中实现稳定性。

    选择排序/快速排序无法做到稳定性