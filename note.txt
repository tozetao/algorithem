### 算法
    如果有一个数据源，该数据源的结构叫做数据结构，例如数组、二叉树、矩阵等。
    在这个结构上需要你完成一个功能，该功能所设计的流程就叫做算法。


### 时间复杂度
    时间复杂度用于评估一个算法的效率。
    时间复杂度是一个算法流程中，常数操作数量的指标，这个指标叫做Big O，
    具体为常数操作数量的表达式中，只要高阶项，不要低阶项，也不要高阶项系数之后，剩下的部分积分f(N)，
    那么该算法的时间复杂度为O(f(N))


- 常数操作
    指完成操作的时间与数据量无关，它是一个固定的代价。
    例如获取数据中某个数据项，它的时间是一个常数，称为O(1)，一般常数操作用C来表示。

- 时间复杂度案例分析
    寻找最大数
    选择排序
    在有序数组寻找指定数：二分与普通遍历的比较。
    俩个有序数组的交集寻找：外排序的算法必须有序的。

### 空间复杂度
    一般在说空间复杂度指的是额外空间复杂度。
    输入的数据不算在额外空间，输出的数据也不算在额外空间，
    为了支持算法的流程需要使用多少辅助空间才能完成该算法的空间叫做额外空间。

- 空间复杂度案例
    数据段的交换，例如有数组1 2 3 4 5，左半区是1 2 3部分，右半区是4 5部分，交换后为4 5 1 2 3


- 算法的最优解
    一个算法的最优解指的是先满足时间复杂度最优的情况下使用最小的空间，先满足时间复杂度最优。

### 冒泡排序
### 选择排序
### 插入排序

### 递归
递归是把一个大的问题划分成若干个小的问题来进行处理，父问题和子问题处理的任务是一样的，不同的是处理的规模不一样。
在代码上的表现递归是方法自己调用自己，在工程上其实是通过系统栈来实现的，每次递归时会把当前代码环境保存压入栈中，一次递归结束则出栈。

- 划分的思想
    在处理一个比较大规模的问题时，可以将其划分为若干个小规模的子问题来处理，直到该问题的规模无法划分，
    通常将无法划分的阶段basecase。

- N个数据项中寻找最大数
    假设有N个数据项，表达式为f(N)，将其划分为f(0 - N/2)和f(N/2+1 - N)进行对比，
    如果所划分的规模能够再次划分将一直划分下去，直到basecase。

### 归并排序
归并排序是一个划分的过程，假设数据项为N，有表达式f(N)，将其划分为f(0 - N/2)和f(N/2+1 - N)进行内排序，
即对俩部分的数据分别排序，然后有序的合并这俩部分数据项。

根据划分的思想，数据项将会被一直划分直到无法划分为止，最后将其合并。

- 时间复杂度为O(N*logN)
    如果整个算法复杂度是T(n)，n是样本量，T是时间复杂度。
    左边部分时间复杂度是T(n/2)，右边部分时间复杂度是T(n/2)，递归的代价是2T(n/2)，
    而合并的代价是O(N)，得到公式：T(n) = 2T(n/2) + O(N)，最后通过master公式计算出该算法流程的复杂度。

    个人理解：
        对半的划分可以划分logN次，如果以一棵树来表示的话会有logN+1层节点，最底层(+1层)的叶子节点不需要合并，
        其他层节点的合并需要进行N个常数级的比较，也就是logN层*N个节点，所以时间复杂度为N*logN。

- 额外空间复杂度
    在合并过程中每层节点需要使用到N个长度的辅助数组，所以额外空间复杂为O(N*logN)

- master公式
    如果一个算法的时间复杂度公式为：T(n) = aT(n/b) + O(N^d)，
    即样本量是b分之n的情况下，发生了a次调用，除出递归行为剩下的复杂度是big o N的d次方，
    对于这种公式，master公式可以直接计算出复杂度。

### 快速排序

### 堆排序