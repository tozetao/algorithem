### 算法
    如果有一个数据源，该数据源的结构叫做数据结构，例如数组、二叉树、矩阵等。
    在这个结构上需要你完成一个功能，该功能所设计的流程就叫做算法。


### 时间复杂度
    时间复杂度用于评估一个算法的效率。
    时间复杂度是一个算法流程中，常数操作数量的指标，这个指标叫做Big O，
    具体为常数操作数量的表达式中，只要高阶项，不要低阶项，也不要高阶项系数之后，剩下的部分积分f(N)，
    那么该算法的时间复杂度为O(f(N))


- 常数操作
    指完成操作的时间与数据量无关，它是一个固定的代价。
    例如获取数据中某个数据项，它的时间是一个常数，称为O(1)，一般常数操作用C来表示。

- 时间复杂度案例分析
    寻找最大数
    选择排序
    在有序数组寻找指定数：二分与普通遍历的比较。
    俩个有序数组的交集寻找：外排序的算法必须有序的。

### 空间复杂度
    一般在说空间复杂度指的是额外空间复杂度。
    输入的数据不算在额外空间，输出的数据也不算在额外空间，
    为了支持算法的流程需要使用多少辅助空间才能完成该算法的空间叫做额外空间。

- 空间复杂度案例
    数据段的交换，例如有数组1 2 3 4 5，左半区是1 2 3部分，右半区是4 5部分，交换后为4 5 1 2 3


- 算法的最优解
    一个算法的最优解指的是先满足时间复杂度最优的情况下使用最小的空间，先满足时间复杂度最优。

### 冒泡排序
### 选择排序
### 插入排序

### 递归
递归是把一个大的问题划分成若干个小的问题来进行处理，父问题和子问题处理的任务是一样的，不同的是处理的规模不一样。
在代码上的表现递归是方法自己调用自己，在工程上其实是通过系统栈来实现的，每次递归时会把当前代码环境保存压入栈中，一次递归结束则出栈。

- 划分的思想
    在处理一个比较大规模的问题时，可以将其划分为若干个小规模的子问题来处理，直到该问题的规模无法划分，
    通常将无法划分的阶段basecase。

- N个数据项中寻找最大数
    假设有N个数据项，表达式为f(N)，将其划分为f(0 - N/2)和f(N/2+1 - N)进行对比，
    如果所划分的规模能够再次划分将一直划分下去，直到basecase。

### 归并排序
归并排序是一个划分的过程，假设数据项为N，有表达式f(N)，将其划分为f(0 - N/2)和f(N/2+1 - N)进行内排序，
即对俩部分的数据分别排序，然后有序的合并这俩部分数据项。

根据划分的思想，数据项将会被一直划分直到无法划分为止，最后将其合并。

- 时间复杂度为O(N*logN)
    如果整个算法复杂度是T(n)，n是样本量，T是时间复杂度。
    左边部分时间复杂度是T(n/2)，右边部分时间复杂度是T(n/2)，递归的代价是2T(n/2)，
    而合并的代价是O(N)，得到公式：T(n) = 2T(n/2) + O(N)，最后通过master公式计算出该算法流程的复杂度。

    个人理解：
        如果将问题规模对半的划分，以一棵完全二叉树来表示的话，会有N+N个节点，树的高度为logN+1层。
        每个节点表示划分的规模并且每个节点会做一次数据的合并，同时每一层节点需要进行N个常数级的比较合并，
        所以时间复杂度为N*logN，最底层(+1层)的叶子节点不需要合并的。

    每个节点进行一次

- 额外空间复杂度
    在合并过程中每层节点需要使用到N个长度的辅助数组，所以额外空间复杂为O(N*logN)

- master公式
    如果一个算法的时间复杂度公式为：T(n) = aT(n/b) + O(N^d)，
    即样本量是b分之n的情况下，发生了a次调用，除出递归行为剩下的复杂度是big o N的d次方，
    对于这种公式，master公式可以直接计算出复杂度。

### 最小数求和
问题：
    有一组数字，要求算出每个数字左边小于它的数字之和的累积，
    例如：4 2 6 0 5 3，
    1左边数字之和是0
    2左边数字之和是0
    6左边数字之和是4+2
    0左边数字之和是0
    5左边数字之和是4+2
    3左边数字之和是2+0
    1左边数字之和是0
    累积之和是6+6+2 = 14

解：
    如果有a、b俩个数，求b的最小和等于求左边小于b的数字之和，可以将其理解成求a右边有多少个数大于它，
    对于a如果有k个数大于它，a所产生的最小和等于a*k，所以只要求出每个数右边有多少个数大于它，就能得到结果。

    归并排序过程中，在合并过程中求出左边每个数据项小于右边数据项的个数之和，就能得到结果。
    例如最小化分的一组组数字a与b，合并时就能求出a小于数字b的数字之和，由于合并是组与组之间的对比，
    所以同一个数是不会被重复计算的。

- 类似的问题有求一组数字的降序对。

### 快速排序
快速排序是取一组数据项中最后一个数据项作为中间数，用于对比剩余的数据项，
小于中间数的数据项位于左边，大于中间数的数据项位于右边。


### 堆排序