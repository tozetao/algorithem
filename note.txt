### 算法
    如果有一个数据源，该数据源的结构叫做数据结构，例如数组、二叉树、矩阵等。
    在这个结构上需要你完成一个功能，该功能所设计的流程就叫做算法。


### 时间复杂度
    时间复杂度用于评估一个算法的效率。
    时间复杂度是一个算法流程中，常数操作数量的指标，这个指标叫做Big O，
    具体为常数操作数量的表达式中，只要高阶项，不要低阶项，也不要高阶项系数之后，剩下的部分积分f(N)，
    那么该算法的时间复杂度为O(f(N))


- 常数操作
    指完成操作的时间与数据量无关，它是一个固定的代价。
    例如获取数据中某个数据项，它的时间是一个常数，称为O(1)，一般常数操作用C来表示。

- 时间复杂度案例分析
    寻找最大数
    选择排序
    在有序数组寻找指定数：二分与普通遍历的比较。
    俩个有序数组的交集寻找：外排序的算法必须有序的。

### 空间复杂度
    一般在说空间复杂度指的是额外空间复杂度。
    输入的数据不算在额外空间，输出的数据也不算在额外空间，
    为了支持算法的流程需要使用多少辅助空间才能完成该算法的空间叫做额外空间。

- 空间复杂度案例
    数据段的交换，例如有数组1 2 3 4 5，左半区是1 2 3部分，右半区是4 5部分，交换后为4 5 1 2 3


- 算法的最优解
    一个算法的最优解指的是先满足时间复杂度最优的情况下使用最小的空间，先满足时间复杂度最优。

### 冒泡排序
### 选择排序
### 插入排序

### 递归
递归是把一个大的问题划分成若干个小的问题来进行处理，父问题和子问题处理的任务是一样的，不同的是处理的规模不一样。
在代码上的表现递归是方法自己调用自己，在工程上其实是通过系统栈来实现的，每次递归时会把当前代码环境保存压入栈中，一次递归结束则出栈。

- 划分的思想
    在处理一个比较大规模的问题时，可以将其划分为若干个小规模的子问题来处理，直到该问题的规模无法划分，
    通常将无法划分的阶段basecase。

- N个数据项中寻找最大数
    假设有N个数据项，表达式为f(N)，将其划分为f(0 - N/2)和f(N/2+1 - N)进行对比，
    如果所划分的规模能够再次划分将一直划分下去，直到basecase。

### 归并排序
归并排序是一个划分的过程，假设数据项为N，有表达式f(N)，将其划分为f(0 - N/2)和f(N/2+1 - N)进行内排序，
即对俩部分的数据分别排序，然后有序的合并这俩部分数据项。

根据划分的思想，数据项将会被一直划分直到无法划分为止，最后将其合并。

- 时间复杂度为O(N*logN)
    如果整个算法复杂度是T(n)，n是样本量，T是时间复杂度。
    左边部分时间复杂度是T(n/2)，右边部分时间复杂度是T(n/2)，递归的代价是2T(n/2)，
    而合并的代价是O(N)，得到公式：T(n) = 2T(n/2) + O(N)，最后通过master公式计算出该算法流程的复杂度。

    个人理解：
        如果将问题规模对半的划分，以一棵完全二叉树来表示的话，会有N+N个节点，树的高度为logN+1层。
        每个节点表示划分的规模并且每个节点会做一次数据的合并，同时每一层节点需要进行N个常数级的比较合并，
        所以时间复杂度为N*logN，最底层(+1层)的叶子节点不需要合并的。

    每个节点进行一次

- 额外空间复杂度
    在合并过程中每层节点需要使用到N个长度的辅助数组，所以额外空间复杂为O(N*logN)

- master公式
    如果一个算法的时间复杂度公式为：T(n) = aT(n/b) + O(N^d)，
    即样本量是b分之n的情况下，发生了a次调用，除出递归行为剩下的复杂度是big o N的d次方，
    对于这种公式，master公式可以直接计算出复杂度。

### 最小数求和
问题：
    有一组数字，要求算出每个数字左边小于它的数字之和的累积，
    例如：4 2 6 0 5 3，
    1左边数字之和是0
    2左边数字之和是0
    6左边数字之和是4+2
    0左边数字之和是0
    5左边数字之和是4+2
    3左边数字之和是2+0
    1左边数字之和是0
    累积之和是6+6+2 = 14

解：
    如果有a、b俩个数，求b的最小和等于求左边小于b的数字之和，可以将其理解成求a右边有多少个数大于它，
    对于a如果有k个数大于它，a所产生的最小和等于a*k，所以只要求出每个数右边有多少个数大于它，就能得到结果。

    归并排序过程中，在合并过程中求出左边每个数据项小于右边数据项的个数之和，就能得到结果。
    例如最小化分的一组组数字a与b，合并时就能求出a小于数字b的数字之和，由于合并是组与组之间的对比，
    所以同一个数是不会被重复计算的。

- 类似的问题有求一组数字的降序对。

### 快速排序
快速排序是取一组数据项中最后一个数据项作为中间数，用于对比剩余的数据项，
小于等于中间数的数据项位于左边，大于中间数的数据项位于右边，然后以中间数为中心点，
将数据项划分为左右俩部分，这俩部分数据项继续按照上述来进行划分归类，直到无法划分为止。

- 中位数划分
    定义一个less指针指向划分数据项数组起始索引的上一个索引，例如索引0指针会指向-1，索引3指针指向2。
    遍历数组将每个数据项与中位数比较，如果小于等于中位数的数据项则与less指针下一个数据项进行交互，
    同时less指针向右移动一位，大于中位数则遍历下一个数据项，以此作为判断遍历完整个数组，则划分结束。

    使用中间数来划分数据项的过程，时间复杂度可以做到O(N)，空间复杂度O(1)

- 荷兰国旗问题
问题：
    假设有一个数组，以最后一个数组作为中位数，请将小于中位数的数据项放在左边，
    大于中位数的数据项放在右边，等于中位数的数据项放在中间，因为荷兰国旗有3种颜色，
    所以该问题叫做荷兰国旗问题。

解答：
    定义left指针，指向起始数据项的上一个位置，用于表示以划分的左半部分，
    定义right之战，指向最后一个数据项位置，表示以划分的右半部分区域。

    中位数为最后一个数据项，遍历数据项列表，将每个数据项与中位数比较，
    如果小于中位数的，将该数据项与left指针的下一个位置数据项交换，同时left指针++，
    如果等于中位数的，遍历下一个数据项，
    如果大于中位数的，将该数据项与right指针的上一个位置数据项交换，同时right指针++，
    对于大于中位数的比较，循环的指针不会走向下一个数据项而是不变，使用大于中位数交换后的数据项再与中位数继续上述比较。

    一直进行上述的比较，当循环的指针碰到right指针的时候，循环结束，
    同时将数据项最后一个数与right指针最边的数进行交换(最后一个数是中位数)。

- 快速排序便是在中位数划分基础上进行的，递归的对一组数据进行中位数划分，直到碰到basecase。

- 快排的最差情况

    如果使用经典快速排序，每次都是使用最后一个数据项来进行中位数划分，
    在对一个从小到大有序的数据项排序时，时间复杂度将会达到O(N^2)，
    因为中位数不够平衡，导致算法进行了N次partition()排序，所以是N*N.

    例如1 2 3 4 5 6 7，倒叙的数据也是相同的道理。

    当最右的划分值导致左右划分不够平均的时候，算法的代价就会变得很高。
    所以经典的快速排序会随机选择划分值，这样碰到最差和最好情况是一个概率的值，
    算法过程的时间复杂度就是一个概率事件，

    通过随机在用概率来求一个总的概率的时间复杂度，是一个长期的期望。

    尽量满足T(N) = 2T(N/2) + O(N)公式

    最好情况
    最差情况
    长期期望

- 空间复杂度
    归并排序的空间复杂度是O(N)，因为在合并数据的时候中，需要一个辅助数据将左右俩边的数据拷贝进去再赋值回去。

    快速排序的空间复杂度是O(logN)，在使用中位数划分后，我们需要一个值在保存断点线，也就是划分好数据后
    左右俩部分数据的交点，这样才能继续递归的划分下去。

    假设中位数划分的很平均，断点线总是在中部位置，那么N个数据会有logN个断点位置，所以空间复杂度是logN，
    当然最差的情况是O(N)，即中位数划分的不够平均，划分的数据要么都在左边要么都在右边，所以需要划分N次

### 堆排序
堆结构是一颗完全二叉树结构，完全二叉树指的是一个父节点只有左节点和右节点，
并且每一层节点都是从左往右填满或者在填满的路上。

堆结构落地时是用一个数据结构来表示完全二叉树结构，
一个父节点i(i是索引位置)，左节点是2*i+1，右节点是2*i+2，相对的一个子节点i，它的父节点是(i-1)/2


- 建立一个大根堆
    整棵树的最大值是根节点，每颗子树的最大值都是这颗子树的根节点。

- heapInsert
    子节点向上比较

- heapify
    父节点向下比较，父节点与子节点最大值的节点交换，如果父节点小于子节点，则遍历结束。

- 复杂度
    建立堆的过程中，第一个节点的代价是log1，第二个节点的代价是log2，第n个节点的代价是logN，
    如果有n个节点，总代价为log1+log2+...+logN，(1+2)/2*n/2，logN^2 = N，所以建立大根堆的过程复杂度是O(N)。

    而在堆排序中，将第一个节点与最后一个节点交换，复杂度是O(1)，交换完后根节点向下调整的过程复杂度是O(logN)，


    完全二叉树的节点为n，它的高度是logN，所以在对堆中某个节点无论是向上或向下调整时，
    时间复杂度都为logN，即走树的高度。


### 桶排序
    

### 排序的稳定性
    原始序列中， 无序 => 有序

    无序数组中值相同的东西，在排成有序之后，相对次序能够保持不变，叫做稳定性。
    例如数据项：x x 3 x 3 x 3，在经过排序后，每个3的原本的次序不变，第一个3在左边，
    第二个3在中间，第三个3在右边。

    冒泡排序、插入排序、可以做到稳定性，

    归并排序可以做到稳定性，在归并过程中实现稳定性。

    选择排序/快速排序无法做到稳定性