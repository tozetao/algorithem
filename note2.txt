### 栈
- 数组实现
- 在栈的基础上，再实现可以获取栈中最小元素，要求pop、getMin()、push()时间复杂度是O(1)
- 队列实现栈

### 队列
- 数组实现
- 栈实现队列
- 猫狗队列


题目：
    设计RandomPool结构，该结构有3种功能：
    insert(key)：插入一个key，做到不重复插入
    delete(key)：删除一个key
    getRandom()：等概率返回结构中的任意一个key

题目：
    转圈打印矩阵，给定一个整型矩阵martix，请按照转圈的方式打印它，比如：
    1   2   3   4
    5   6   7   8
    7   10  11  12
    13  14  15  16
    打印结果为：1 2 3 4 8 12 16 15 14 13 7 5 6 7 11 10，要求时间复杂度是O(1)。

题目：
    之字型来打印矩阵。

题目：
    给定一个N*M的整型矩阵和一个整数k，martix每一行每一列都是有序的，
    实现一个函数，判断k是否在矩阵中，例如：
    0   1   2   5
    4   3   4   7
    4   4   4   8
    5   7   7   9
    如果k是7返回true，如果k是6返回false，要求时间复杂度是O(N+M)，额外空间复杂度是O(1)

    左下角和右下角淘汰不了？

题目：
    打印俩个有序链表的公共部分
    给定俩个有序链表的头指针head1和head2，打印俩个链表的公共部分。

题目：
    给定一个链表的头结点head，请判断链表是否为回文结构。
    进阶：如果链表长度为N，时间复杂度达到O(N)，额外空间复杂度达到O(1)

    额外空间复杂度O(N)的解法

    1 2 3 4 4 3 2 1
    快指针走2步，慢指针走1步，
    如果有偶数个数据项，快指针走完后慢指针会位于数据项中部的右边一个数，
    如果有奇数个数据项，快指针走完后满指针会位于数据项中部。

    额外空间复杂度O(1)的解法

题目：
    将单向链表按某值划分为左边小、中间相等、右边大的形式。

    给定一个单向链表的头结点head，节点的值类型是整型，再给定一个数pivot，实现一个调整链表的函数，
    将链表调整为左边的值都是小于pivot，中间的值等于pivot，右边的值大于pivot。

    进阶：额外空间要求为O(1)

题目：
    复制含有随机指针节点的链表。
    public class Node{
        public int value;
        public Node next;
        public Node rand;

        public Node(int data){
            this.value = data;
        }
    }

题目：
    俩个单链表相交的一系列问题

    在本题中，单链表可能有环，也可能无环，给定俩个单链表的头节点head1和head2，
    这俩个链表可能相交也可能不相交。请实现一个函数，如果俩个链表相交，请返回相交的第一个节点，
    如果不相交，返回null。

    要求：如果链表1的长度为n，链表2的长度为m，时间复杂度要达到O(N+M)，额外空间复杂度为O(1)

- 链表是否有环的检查
    解1：遍历链表并将节点存储到hashset中，如果所遍历的节点存在于hashset中，代表着有环
    解2：定义指针F、指针S，F指针走2步，S指针走1步，当S、F指针相遇时链表有环，如果要找到入环节点，只需要让F指针回到原点，让F和S指针每次前进一步，当它门再次相遇的节点就是入环节点。


- 俩个无环的链表，如何判断是否相交，如果相交如何返回相交节点
    俩个无环的链表，如果俩个链表的最后一个节点是相同的，则俩个链表相交，这是因为只有最后一个节点相同，才不会破坏链表next指针的结构。
    如果相交，让长度较大的链表减长度较小的链表得到差值，再让长度较大的链表减去该差值，这时俩个链表同时前进，当俩个节点相遇时就能得到相交的节点

- 一个有环的链表和一个无环的链表
    一个有环的链表和一个无环的链表，节点是不可能相交的，如果相交会破坏链表的next指针结构。

- 俩个链表都是有环的
    俩个有环的链表，会有3种可能，
    第一种是俩个有环的链表都是独立的
    第二种是B链表的尾部节点指向A链表的环中某个节点，
    最后是B链表的尾部节点指向A链表非环节点中的某个节点

    如果A链表的入环节点等于B链表的入环节点，属于最后种情况，我们将环屏蔽掉，在求相交节点其实是求无环链表的相交节点。

    如果俩个入环节点都不相等，则属于第一和第二俩种情况，这时候用A链表的入环节点往下一个节点遍历，如果能找到B链表的入环节点则属于第二种情况，
    否则属于第一种情况，针对第二种情况，俩个入环节点都可以算作相交的点，只不过距离不同。




### 哈希函数
哈希函数有几百种实现方式。

性质1：哈希函数又叫做离散函数，hash()该函数接受的输入域是无穷的，而返回的输出域是有限的。
性质2：哈希函数不是随机函数，相同的输入值一定得到相同的返回值。
性质3：因为输入域是无穷的，而输出域是有限的，这会导致不同的输入域对应同一个输出域，这种情况叫做哈希碰撞。
性质4：离散性：虽然输入域是无穷大，输出域是一个S，但是不同的输入如果想得到整个S域上的返回值，各个输入域在在整个S域上的返回值会均匀分布。

由于离散性，哈希函数能够将有规律的数据进行打乱，有规律的数据通过哈希函数计算后千差万别，这就是哈希函数的作用。


### 哈希表
哈希表是由哈希函数实现的一种结构。

哈希表可以是一个数组结构，只不过每个元素是一个链表，这些链表存储不同的数据，
每个数据在存储到链表中时，会先通过哈希函数计算出数据的key，通过key确定在数据中对应的链表，在插入进去。

例如有一个长度是17的数组，即索引是0-16，有一个数据项是"左"字，经过哈希函数计算后key是2^12次方，
再将其%以17，根据得到的key插入到对应的链表中。

纵向的是一个存放链表的数组，横向是一个链表，这样所组成的表就叫做哈希表，所有的链表长度是趋于平均的






