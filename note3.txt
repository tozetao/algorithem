


### 随时找到数据流的中位数
有一个源源不断吐出整数的数据流，假设有足够的空间保存整数，请设计一个结构能够随时取出之前吐出所有数的中位数。
要去加入一个数的复杂度是logN，取出中位数的复杂度是o(1).

解答：
    使用大根堆存储前n/2的数字，使用小根堆存储后n/2的数字。
    在存储数字时与大根堆堆顶数据项对比，如果小于等于堆顶的数字，则加入大根堆，否则加入小根堆。
    在加入时对比俩个堆数据项数量的差值，如果超过1(即>=2)，将size大的堆弹出一个数据项到另外一个堆，这是为了保存俩个堆存储数据项的平衡。

### 哈夫曼编码问题
一块金条切成俩半，是需要花费和长度数值一样的铜板的，比如长度20的金条不管切割成多大的俩半，都需要花费20铜板，
一群人想要分整块金条，怎么分最省铜板。

例如：给定数组10 20 30，代表一共3个人，也代表长度10+20+30的金条。
金条要分成3个部分，如果先分成10和50，花费60铜板，再将50分成20+30，花费50铜板，一共花费110.
如果将金条分成30和30，花费60，再将30分成10和20，花费30，一共花费90

输入一个数组，返回分割的最小代价。
这个问题其实是哈夫曼编码问题。

10 20 30的划分是下面这棵树的代价
        60
    30      30
10      20

求的是非叶子节点代价的总和，30的节点和60的节点相加。这个问题就相当于我给你叶子节点，你选择一个什么合并顺序，能导致非叶子节点求和最小。

解答：通过最小堆来求解，每次从堆中弹出俩个数相加，相加的值就是当前节点相加的代价，将相加的代价压会堆中，
再从堆中弹出俩个数相加，所相加的代价再压回堆中，重复此过程直到堆中只剩下一个数字，这时候把代价相加，求出结果。


###
输入：
    参数1，正数数组costs
    参数2，正数数组profits
    参数3，正数k
    参数4，正数m

    costs[i]表示i号项目的花费，
    profits[i]表示i号项目在扣除花费之后还能挣到的钱。
    k表示你不能并行，只能串行的最多做k个项目，
    m表示你初始的资金。

    说明：你每做完一个项目，马上获得的收益，可以支持你去做下一个项目。
    输出：你最后获得的最大钱数。

    收益、花费说明：假设有1个项目，c=3,p=7，c是项目花费，p是扣除花费后的利润，那么总的收益等于3+7。


    模拟：假设有3个项目，允许你做2个项目(k=2)
    c=1,p=4     c=2,p=3     c=5,p=7

    初始资金m=3，选择项目时只能选择启动资金大于等于项目花费的项目，并且选择收益最高的项目(即c+p)
    第一个选择c=3的项目，因为其收益最高且花费小于启动资金，选择后c=3+4=7
    第二个选择c=5的项目，

    代码实现：
        所有项目按照花费组成小根堆，再按照收入组成大根堆(起始为空)

        从小根堆弹出项目，只要项目花费小于等于启动资金，全部放到大根堆，大根堆存放的是能够启动的项目，直到要弹出的项目大于启动资金停止弹出。

        然后从大根堆弹出堆顶的项目来做，因为堆顶代表的项目收益最高，初始资金增加。
        然后再从小根堆中弹出可以启动的项目加入到大根堆中，再从大根堆中弹出收益最高的项目来做。

        上述的过程重复k次，就能算出最大收益了。

### 二叉树的先序遍历、中序遍历、右序遍历。
先序遍历：先中、再左、再右。
中序遍历：先左、再中、再右，先打印左子树、再打印当前节点、再打印右子树
后序遍历：先打印左子树，再打印右子树，再打印中间节点。

你可以理解成对于每一个节点的遍历操作，例如先序遍历是先打印中间节点，再打印节点的左子树，再打印节点的右子树

代码实现：递归版本、非递归版本
























### 折纸问题
请把一段纸条放在桌子上，然后从纸条的下边向上方对折一次，压出折痕后展开，此时折痕是凹下去的，即折痕突起的方向指向纸条的背面，如果从纸条的下边向上对折俩次，压出折痕后展开，此时有3条折痕，从上到下依次是下折痕、下折痕和上折痕。

要求：给定一个输入参数N，代表纸条从下向上连续对折n次，请从上到下打印所有折痕的方向。

解：从上到下将折痕建立成一颗二叉树，打印的方式其实是二叉树的中序遍历，这棵树的头节点为下折痕，每颗左子树的头节点都为下折痕，每颗右子树的头结点都为右折痕。

分析：如果对折n次，将产生2^n-1个折痕，联想满二叉树

1. 如果满二叉树的高度是n，它的节点是2^n-1


### 在二叉树中找到一个节点的后继节点
新的二叉树节点类型如下：
    public class Node{
        public int value;
        public Node left;
        public Node right;
        public Node parent;

        public Node(int value){
            this.value = value;
        }
    }

该结构比普通的二叉树多出一个指向父节点的parent指针，假设有一颗Node类型的节点组成的二叉树，
树中每个节点的parent指针都正确的指向自己的父节点，头结点的parent指向null，只给二叉树中的某个节点，
请实现返回Node的后继节点的函数。

在二叉树的中序遍历中，node的下一个节点叫做node的后继节点。

解：
    简单的处理是将树进行中序遍历建立一个序列，再遍历寻找一个节点的下一个节点，这种时间复杂度是O(N)

    假设一个节点是x，在中序遍历中，
    如果x节点有右子树，x节点的后继节点等于右子树最左边的一个节点。

    如果x节点没有右子树，x节点是它父亲节点的左孩子，这种情况父亲节点是它的后继，

    如果x节点没有右子树，x节点是它父亲节点的右孩子，
    这种情况下，x向上寻找的节点中，某个节点是它父亲节点的左孩子时，这个节点就是x节点的后继节点。
    因为x节点没有右子树，并且x节点是在右子树中，所以需要寻找这颗右子树的根节点是哪个最近节点的左孩子。


    (其实是在寻找x节点是哪个节点的左子树上的最后一个节点，求得是哪个节点)



### 在数组中找到一个局部最小的位置
定义局部最小概念，arr长度为1时，arr[0]是局部最小，arr的长度为n时(n>1)，如果arr[0]<arr[1]，
那么arr[0]是局部最小，如果arr[n-1]<arr[n-2]，那么arr[n-1]是局部最小；
如果0<i<n-1，既有arr[i]<arr[i-1]，又有arr[i]<arr[i+1]，那么arr[i]是局部最小。
给定无序数组arr，已知arr中任意俩个相邻的数都不相等，写一个函数只需返回arr中任意一个局部最小出现的位置即可。





### 并查集
假设有n个集合，这个集合是数学上的概念，最开始每个集合都是最细粒度的，都是由一个元素构成的集合。

并查集支持的操作有：
- isSameSet：查询俩个元素是否属于一个集合
- union：合并，例如把a元素的集合和b元素的集合合并成一个大集合。

落地结构：
    一个Node节点，拥有一个值val属性，一个Node类型的parent属性，一个int型的nums变量，记录集合节点大小。

    假设有5个元素，它们各自成一个集合，每个元素各自成一个集合，并且都是指向自己，
    例如：1的上级指针指回自己，由于它们都是指向自己，代表着各自是集合中的代表节点。

    代表点用于标识集合。

    假设现在1元素和2元素合并成一个集合，由于这俩个集合的节点数量都是1，所以任意一个元素都可以作为代表节点。
    合并时1元素的parent指向2元素，现在它们成为一个集合。
    这个集合的含义：1节点的parent指向2节点，所以1节点是属于2节点这个集合。

    isSameSet：
        查询俩个元素是否属于一个集合，
        从某个元素向上一直寻找直到寻找到一个代表节点(指向自己的节点)

        在找代表节点的过程中，沿途的需要打平(即将沿途的所有节点指向该集合的代表节点)，
        例如找A节点的代表节点，向上寻找的这条链上的节点都指向代表节点，在B节点寻找代表节点也是一样。

    union：
        节点数量少的集合代表点parent指向节点数量多的集合代表点。


代码实现：
    一个HashTable fatherMap，key和value存储的都是元素，它们的关系是key元素的代表节点是value元素
    一个HashTable sizeMap，key存储元素，value是int型，key表示的是元素所在集合中节点的数量，并且key元素是代表节点该数据才是有效的。

时间复杂度
    如果有n个元素，查询的次数+合并的次数，如果次数逼近O(N)或以上，单次查询和单次合并，它的时间复杂度平均O(1)，是所有查询和合并的平均代价是O(1)








### morris遍历
1. current节点无左子树，curent向右移动
2. current有左子树，找左子树最右的节点(mostRight)
    如果mostRight的右孩子为空，使mostRight的右孩子指向current，然后current向左移动
    如果mostRight的右孩子为current节点，mostRight的右孩子置空，然后current向右

概念：
    对于任何一个有左子树的节点俩次回到自己，对于没有左子树的节点只到达这个节点一次的遍历。
    整体符合先中间节点，再左子树再右子树遍历情况。

    凡是没有左子树的节点都遍历了一次，有左子树的节点都遍历俩次。
    而且在遍历俩次的过程中，遵循的顺序是先回到当前节点，然后遍历完自己的左子树后再回到当前节点遍历完右子树的过程。

额外空间复杂度是O(1)，时间复杂度是O(N)


### 搜索二叉树
概念：任何一个节点它的左子树都比它小，它的右子树都比它大。

在一颗平衡的搜索树中搜索一个节点，时间复杂度是O(logN)，
但是如果树是不平衡的，最差是形成一个链表，时间复杂度是O(N)


### AVL树
定义：在一颗树中任何一个节点的左子树和右子树的高度之差的绝对值不会超过1

### 红黑树
红黑树的定义：
1. 节点非黑即红
2. 根节点一定是黑色
3. 每个底部节点一定是黑色，底部节点是指叶子节点的null孩子节点
4. 每个红色节点它的子节点一定是黑色
5. 任意一个节点自己的链上的黑色节点数量是一样的

任意一个节点的长链的高度在倍数上不要超过短链的高度一倍，
例如某个节点的左分支是红/黑/红/黑/红/黑，另外一个分支是黑/黑/黑/


在一个头节点出发，一条长链的高度永远不大于2倍的短链的高度


### SB树
任意一个节点，它整棵树的节点数量一定不小于它侄子的节点数量。

叔叔树、侄子树

叔叔树的节点个数不要比任何一个侄子树的节点个数少















### 原动作
红黑树、SB树、AVL树这几种树的调整都是俩个原动作的组合：
- 左旋
- 右旋


### 如何调整

当我插入一个节点或者删除一个节点的时候，你插入位置或者删掉位置向上找到第一个不平衡的位置，
将其不平衡的位置调整成平衡的，整颗树都会平衡了。

这是一个数学结论。

RR型调整：插入节点向上寻找不平衡的节点时，从该节点向下看发现是都是右边的节点不平衡
LL型调整：

LR型调整：

上述几个平衡树在进行平衡性调整时，平衡性的原子性操作都是左旋转和右旋转这俩个操作的组成，
例如AVL树它有4种情况需要进行平衡性调整：
- RR型：
- LL型：
- LR型：
- RL型：

红黑树的调整也是这俩个原子性操作，但是情况特别多，
插入操作5种情况：
删除操作8种情况：
