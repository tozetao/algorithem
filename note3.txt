


### 随时找到数据流的中位数
有一个源源不断吐出整数的数据流，假设有足够的空间保存整数，请设计一个结构能够随时取出之前吐出所有数的中位数。
要去加入一个数的复杂度是logN，取出中位数的复杂度是o(1).

解答：
    使用大根堆存储前n/2的数字，使用小根堆存储后n/2的数字。
    在存储数字时与大根堆堆顶数据项对比，如果小于等于堆顶的数字，则加入大根堆，否则加入小根堆。
    在加入时对比俩个堆数据项数量的差值，如果超过1(即>=2)，将size大的堆弹出一个数据项到另外一个堆，这是为了保存俩个堆存储数据项的平衡。

### 哈夫曼编码问题
一块金条切成俩半，是需要花费和长度数值一样的铜板的，比如长度20的金条不管切割成多大的俩半，都需要花费20铜板，
一群人想要分整块金条，怎么分最省铜板。

例如：给定数组10 20 30，代表一共3个人，也代表长度10+20+30的金条。
金条要分成3个部分，如果先分成10和50，花费60铜板，再将50分成20+30，花费50铜板，一共花费110.
如果将金条分成30和30，花费60，再将30分成10和20，花费30，一共花费90

输入一个数组，返回分割的最小代价。
这个问题其实是哈夫曼编码问题。

10 20 30的划分是下面这棵树的代价
        60
    30      30
10      20

求的是非叶子节点代价的总和，30的节点和60的节点相加。这个问题就相当于我给你叶子节点，你选择一个什么合并顺序，能导致非叶子节点求和最小。

解答：通过最小堆来求解，每次从堆中弹出俩个数相加，相加的值就是当前节点相加的代价，将相加的代价压会堆中，
再从堆中弹出俩个数相加，所相加的代价再压回堆中，重复此过程直到堆中只剩下一个数字，这时候把代价相加，求出结果。


###
输入：
    参数1，正数数组costs
    参数2，正数数组profits
    参数3，正数k
    参数4，正数m

    costs[i]表示i号项目的花费，
    profits[i]表示i号项目在扣除花费之后还能挣到的钱。
    k表示你不能并行，只能串行的最多做k个项目，
    m表示你初始的资金。

    说明：你每做完一个项目，马上获得的收益，可以支持你去做下一个项目。
    输出：你最后获得的最大钱数。

    收益、花费说明：假设有1个项目，c=3,p=7，c是项目花费，p是扣除花费后的利润，那么总的收益等于3+7。


    模拟：假设有3个项目，允许你做2个项目(k=2)
    c=1,p=4     c=2,p=3     c=5,p=7

    初始资金m=3，选择项目时只能选择启动资金大于等于项目花费的项目，并且选择收益最高的项目(即c+p)
    第一个选择c=3的项目，因为其收益最高且花费小于启动资金，选择后c=3+4=7
    第二个选择c=5的项目，

    代码实现：
        所有项目按照花费组成小根堆，再按照收入组成大根堆(起始为空)

        从小根堆弹出项目，只要项目花费小于等于启动资金，全部放到大根堆，大根堆存放的是能够启动的项目，直到要弹出的项目大于启动资金停止弹出。

        然后从大根堆弹出堆顶的项目来做，因为堆顶代表的项目收益最高，初始资金增加。
        然后再从小根堆中弹出可以启动的项目加入到大根堆中，再从大根堆中弹出收益最高的项目来做。

        上述的过程重复k次，就能算出最大收益了。





### 折纸问题
请把一段纸条放在桌子上，然后从纸条的下边向上方对折一次，压出折痕后展开，此时折痕是凹下去的，即折痕突起的方向指向纸条的背面，如果从纸条的下边向上对折俩次，压出折痕后展开，此时有3条折痕，从上到下依次是下折痕、下折痕和上折痕。

要求：给定一个输入参数N，代表纸条从下向上连续对折n次，请从上到下打印所有折痕的方向。

解：从上到下将折痕建立成一颗二叉树，打印的方式其实是二叉树的中序遍历，这棵树的头节点为下折痕，每颗左子树的头节点都为下折痕，每颗右子树的头结点都为右折痕。

分析：如果对折n次，将产生2^n-1个折痕，联想满二叉树

1. 如果满二叉树的高度是n，它的节点是2^n-1


### 在二叉树中找到一个节点的后继节点
新的二叉树节点类型如下：
    public class Node{
        public int value;
        public Node left;
        public Node right;
        public Node parent;

        public Node(int value){
            this.value = value;
        }
    }

该结构比普通的二叉树多出一个指向父节点的parent指针，假设有一颗Node类型的节点组成的二叉树，
树中每个节点的parent指针都正确的指向自己的父节点，头结点的parent指向null，只给二叉树中的某个节点，
请实现返回Node的后继节点的函数。

在二叉树的中序遍历中，node的下一个节点叫做node的后继节点。

解：
    简单的处理是将树进行中序遍历建立一个序列，再遍历寻找一个节点的下一个节点，这种时间复杂度是O(N)

    假设一个节点是x，在中序遍历中，
    如果x节点有右子树，x节点的后继节点等于右子树最左边的一个节点。

    如果x节点没有右子树，x节点是它父亲节点的左孩子，这种情况父亲节点是它的后继，

    如果x节点没有右子树，x节点是它父亲节点的右孩子，
    这种情况下，x向上寻找的节点中，某个节点是它父亲节点的左孩子时，这个节点就是x节点的后继节点。
    因为x节点没有右子树，并且x节点是在右子树中，所以需要寻找这颗右子树的根节点是哪个最近节点的左孩子。


    (其实是在寻找x节点是哪个节点的左子树上的最后一个节点，求得是哪个节点)
