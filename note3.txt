### 布隆过滤器
布隆过滤器是一个集合的概念，常应用于爬虫项目或黑名单项目的一个结构，它是为了查询某个数据是否在一个集合中的结果。
例如有一亿个黑名单url，每个url有64个字节，虽然可以将其装到hashtable中来确定数据项是否存在，然后这太耗内存了，是不可取的。

- 大数组结构
    数组中的每个位置都是一个比特，例如：
    int[] array = new int[100];

    定义了一个100长度的int型数组，每个数据项都是32位的int型，以二进制的方式来看，
    array[0]代表0-31位，array[1]代表32-63位，以此类推，100长度的int型数组可以代表100*32位个信息。

    默认所有位都是0的，在对某个位进行操作时，例如要对3120位操作将其改为1，
    由于每个数据项是32位的，所以先找出在哪个数据项，将3120/32可以得到要操作的数据项，
    在得到要操作的数据项后，只需要将3120%32算出要操作的位数，通过位运算将其赋值为1即可。

布隆过滤器就是比特类型的数组，一个位的数不是0就是1，假设这个数组最低位是0，最高位是m-1，长度是m，
长度是m的bit位数组，大小是m/8个字节。

添加一个url
在有这个数组后，添加一个url时，准备k个哈希函数，分别是h1-hk，url经过k个哈希函数计算后会得到v1-vh个哈希值，
将v1-vh个哈希值分别%m，计算出来的k个值会在0至m-1之间，只需要相应的k个位改为1即可。

注意哈希函数要独立的非重复实现的。

- 验证一个url
将url经过k个哈希函数计算并模以m，查看k个值对应的位是否为1，只要有1个值对应的位不为1，那么就认为非重复，相反则重复。

- 失误率
    因为布隆规律器空间太小，它已经有相当多的位置变黑了，在查询一个url是，位是1的概率就很高了，自然出错。
    例如处理1亿个url时，布隆过滤器m只有10个空间，假设有4个哈希函数，%10后的4个值分布在m空间上，重复的概率是很高的，

- 预期失误率的计算
    假设样本量为n，失误率为p，求布隆过滤器m的比特位大小和哈希函数个数。

    m = - (n*lnP) / (ln2)^2
    k = ln2 * m/n 约等于 0.7 * m/2

    由于m和k求出来的结果可能是小数，所以要向上取整，取整后概率P也发生变化，
    P = (1 - E的负n*k/m次方)的k次方

    假设有10亿个url，要求失误率为万分之一，求m和k。






### 一致性哈希

- 经典服务器架构
可以用于解决经典服务器架构问题，经典服务器架构的话会有一台前端web服务器和多台后台服务器，
前端web服务器负责分发请求到后台服务器，分发逻辑是这样的，前端服务器通过请求的key(可以是ip地址)进行哈希处理，
再讲该哈希值模以后台服务器数量，这样请求会均匀的分发到每台服务器上面。

但是该架构在新增或减少后台机器时就会发生数据迁移问题，例如原本A请求的数据是存放在A机器的，新增服务器后哈希值模以4，
可能会分发到其他服务器，这时候A机器上缓存中的数据就需要迁移到另外一台服务器上，数据迁移很繁琐和复杂。

- 一致性哈希
1. 假设哈希函数产生的域是0-2^64次方，将产生的哈希域想象成一个首位相连的环，0 1 2 ... 一直连接到2^64次方
2. 设定前端与后端服务器均是以ip地址作为哈希函数的输入，我们将后端服务器的ip地址做哈希处理，产生的值分布到哈希域环中。
3. web服务器会存储排序后的后端服务器哈希值，当请求过来时将请求的ip地址哈希处理，将产生的哈希值在后端哈希列表中二分的对比，
    大于该值的哈希值所对应的服务器便是要分发的服务器。

新增服务器与减少服务器的状态
    新增服务器时会将ip地址哈细化分布到哈希环中，也就是说该服务器在哈希环中逆时针碰到的服务器这段哈希域都属于新增服务器处理的范畴，这段哈希域原本是属于顺时针碰到的服务器处理的，数据迁移时只需要把顺时针碰到的服务器所管辖的这段环中的数据迁移到新增服务器即可，
    移除服务器也是相同的道理。

缺点1：哈希函数只有在输入域数量起来的时候，哈希的特性才能发挥，如果在机器少的时候，没办法保证机器是平均分布在哈希环上面的，这样机器负载就不均衡了。
缺点2：即使原始场景机器负载均衡了，但是在加机器后，就会破坏哈希环原本均衡的状态。

引入虚拟节点便可以解决这俩个缺点。
假设有3台机器，让每一台机器对应1万个虚拟节点，这样将会有3万个虚拟节点，每个虚拟节点都是通过哈希函数计算出来的，
这样这每台机器就会在哈希环上占据3分之一段，这是当哈希值量起来的时候。

那么在加机器的时候，例如加第四台机器，这时候每台机器就在哈希环上就占据4分之一段，也就是说原先每天机器会有4分之一请求被占据了。

如何算出虚拟节点，假设机器1的ip是192.24.22.11，将其当做字符串处理，让-1类似的后缀加载iip上，然后进行哈细化处理，这样虚拟出了10000虚拟节点了。



### 随时找到数据流的中位数
有一个源源不断吐出整数的数据流，假设有足够的空间保存整数，请设计一个结构能够随时取出之前吐出所有数的中位数。
要去加入一个数的复杂度是logN，取出中位数的复杂度是o(1).

解答：
    使用大根堆存储前n/2的数字，使用小根堆存储后n/2的数字。
    在存储数字时与大根堆堆顶数据项对比，如果小于等于堆顶的数字，则加入大根堆，否则加入小根堆。
    在加入时对比俩个堆数据项数量的差值，如果超过1(即>=2)，将size大的堆弹出一个数据项到另外一个堆，这是为了保存俩个堆存储数据项的平衡。

### 哈夫曼编码问题
一块金条切成俩半，是需要花费和长度数值一样的铜板的，比如长度20的金条不管切割成多大的俩半，都需要花费20铜板，
一群人想要分整块金条，怎么分最省铜板。

例如：给定数组10 20 30，代表一共3个人，也代表长度10+20+30的金条。
金条要分成3个部分，如果先分成10和50，花费60铜板，再将50分成20+30，花费50铜板，一共花费110.
如果将金条分成30和30，花费60，再将30分成10和20，花费30，一共花费90

输入一个数组，返回分割的最小代价。
这个问题其实是哈夫曼编码问题。

10 20 30的划分是下面这棵树的代价
        60
    30      30
10      20

求的是非叶子节点代价的总和，30的节点和60的节点相加。这个问题就相当于我给你叶子节点，你选择一个什么合并顺序，能导致非叶子节点求和最小。

解答：通过最小堆来求解，每次从堆中弹出俩个数相加，相加的值就是当前节点相加的代价，将相加的代价压会堆中，
再从堆中弹出俩个数相加，所相加的代价再压回堆中，重复此过程直到堆中只剩下一个数字，这时候把代价相加，求出结果。


###
输入：
    参数1，正数数组costs
    参数2，正数数组profits
    参数3，正数k
    参数4，正数m

    costs[i]表示i号项目的花费，
    profits[i]表示i号项目在扣除花费之后还能挣到的钱。
    k表示你不能并行，只能串行的最多做k个项目，
    m表示你初始的资金。

    说明：你每做完一个项目，马上获得的收益，可以支持你去做下一个项目。
    输出：你最后获得的最大钱数。

    收益、花费说明：假设有1个项目，c=3,p=7，c是项目花费，p是扣除花费后的利润，那么总的收益等于3+7。


    模拟：假设有3个项目，允许你做2个项目(k=2)
    c=1,p=4     c=2,p=3     c=5,p=7

    初始资金m=3，选择项目时只能选择启动资金大于等于项目花费的项目，并且选择收益最高的项目(即c+p)
    第一个选择c=3的项目，因为其收益最高且花费小于启动资金，选择后c=3+4=7
    第二个选择c=5的项目，

    代码实现：
        所有项目按照花费组成小根堆，再按照花费组成大根堆(起始为空)
        从小根堆弹出项目花费，只要花费小于等于启动资金，全部放到大根堆，大根堆存放的是能够启动的项目，直到要弹出的项目大于启动资金停止弹出。

        然后从大根堆弹出堆顶的项目来做，因为堆顶代表的项目收益最高，初始资金增加。




