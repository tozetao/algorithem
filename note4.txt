### 图



### 领接表、矩阵
入度：有多个节点指向我，in
出度：我指向多少个节点，out

### 宽度优先遍历
1. 利用队列实现
2. 从源节点开始依次按照宽度进队列，然后弹出
3. 每弹出一个点，把该节点的所有没有进过队列的邻接点放入队列
4. 直到队列边空

### 深度优先遍历
1. 利用栈实现
2. 从源节点开始把节点按照深度放入栈，然后弹出
3. 每弹出一个节点，会把栈顶节点(即回到上一个节点)下一个没有进入栈中的邻接点放入栈中，直到节点最深度。
4. 重复次过程直到栈为空。

### 拓扑排序算法
- 适用范围：要求有向图，且有入度为0的节点，且没有环
- 说明：入度为0的节点意思是没有任何节点指向它，这样该节点就不会依赖其他节点了。

怎么决定一件事情先后顺序，当我执行到任何一个事情的时候不被block，决定这个顺序就叫做拓扑排序。

在对图中的节点排序时，每排序一个节点时，要求它所依赖的节点都已经具备(排序)了。
同一级别的节点可以无序。


代码实现：
    1. 先找到入度为0的节点
    2. 删除入度为0的节点，进行记录排序，删掉入度为0的节点后会有新的入度为0的节点
    3. 继续新的入度为0的节点，重复次过程直到没有节点。

### 最小生成树
只适合无向图，在保证这个图所有节点连同的情况下，所有节点的边的权重加起来是最小的。


### kruskal算法
- 适用范围：要求无向图
- 最小生成树的一种实现

实现：
    从小权重的边开始考察，如果边权重小并且没有回路就采用它，
    采用一条边连起来的俩个节点就形成了一个集合，可以用并查集来判断是否回路，
    从小到大依次考察，直到所有节点都遍历过。

    假设每个节点都是一个集合，一条边的引入表示将俩个节点也就是集合连同了，这时候俩个集合合并了，
    所以如果有俩个节点都是属于同一个集合中，代表着有环。


### prim算法
- 适用范围：要求无向图
- 最小生成树的一种实现

实现：
    先考察点，再考察边。

    从任意一个点出发，将该节点的所有出度边加入最小堆中，
    从堆中弹出一条权值最小的边，只要这条边出度节点未使用过便采用该节点，

    然后再进行同样的操作，将该出度节点的所有出度边加入堆中并弹出一条权值最小的边，
    同样判断边的出度节点是否使用过，如果使用过再堆中继续弹出直到碰到一条出度节点未被使用过的边。

    重复次过程直到堆为空。


    从堆中弹出的操作等于： 每次选的就是所有被解锁边 与之相连的所有最小边中的最小权值

    所有点被解锁了，所有点所连接的所有边考察最小权重的那条边，堆的操作就是做这条事情。

### Dijkstra算法
- 适用范围：有向图并且没有权值为负数的边
- 在一个环里面，不会产生一个完全为负的环。

问题：求一个点出发到所有点的最短距离
1. 自身节点到自己上的代价是0
2. 每次相邻节点入map，如果不在map直接加入map中，值是原始节点到相邻节点的距离，如果在map中，更新原始节点到map节点中的值。
3. 每次从map中取出一个代价最低节点，继续第二步的操作。

注意：在map中加入的节点代表着原始节点到该节点的距离(权值)

改进：
    对上面方法的改进
    - 最小堆容器保存原点到其他节点的最短距离
    - pop()：堆弹出的节点是原点到某个节点距离最小值的一个节点，并且这个最小距离的值是未确定的
    - isEmpty()：堆节点未空或所有节点的最短距离全部确定

    第一种方法在找一个最小距离的节点时，时间复杂度是O(N)，使用堆结构将优化到logN