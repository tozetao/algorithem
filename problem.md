
- 问题：一个long long型无序数组中，如果排好序后求相邻俩个数的最大差值，要求时间复杂度为O(N）
    1. 数据在有序的情况下，俩俩比较才能求出最大差值
    2. 从无序到有序下，普通排序算法时间复杂度不满足要求，使用数值范围的桶排序也不满足要求，需要使用桶排序的思想来改进算法。

- 猫狗队列
    起始就是归并排序的外排序过程



#### 链表

- 俩个有序的链表，要求查询出相同数据的节点

- 题目：
    复制含有随机指针节点的链表。
    public class Node{
        public int value;
        public Node next;
        public Node rand;

        public Node(int data){
            this.value = data;
        }
    }

- 链表还有一道题目没做完

### Hash
- 哈希函数实现
- HashTable实现
- 一致性哈希
- 布隆过滤器

### 第四课有不少题没有做

#### 在数组中找到一个局部最小的位置
    - arr长度为1时，arr[0]是局部最小，
    - arr的长度为n时(n>1)，如果arr[0]<arr[1]，那么arr[0]是局部最小
    - arr的长度为n时(n>1)，如果arr[n-1]<arr[n-2]，那么arr[n-1]是局部最小
    -  如果0<i<n-1，既有arr[i]<arr[i-1]，又有arr[i]<arr[i+1]，那么arr[i]是局部最小。

    给定无序数组arr，已知arr中任意俩个相邻的数都不相等，写一个函数只需返回arr中任意一个局部最小出现的位置即可。