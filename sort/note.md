#### 算法

有一个数据源，该数据源的结构叫做数据结构。在这个数据结构基础上实现一个功能所设计的流程就叫做算法。

#### 时间复杂度

- 时间复杂度

  时间复杂度是一个算法流程中常数操作数量的指标，该指标叫做Big O，

  具体为常数操作数量的表达式中，只要高阶项，不要低阶项，也不要高阶项系数之后剩下的部分记为f(N)，

  那么该算法的时间复杂度是O(f(N))

- 常数操作

  指计算机完成一个操作的时间与数据量等等额外因素无关，它是一个固定的代价，一般记为C。

  例如在数组中获取一个数据项，它的时间是一个常数，称为O(1)


- example：寻找一个数组中最大的数据项

  ```php
  function findMax($array){
      $temp = $array[0];
      $length = count($array);
      
      for($i=0; $i<$length; $i++){
          if($temp < $array[$i]){
              $temp = $array[$i];
          }
      }
      return $tmep;
  }
  ```

  在一个数组中寻找最大的数据项，简单的方法是用一个变量存储最大值，遍历整个数组，只要发现有数据项大于该变量就更新该变量的最大值。

  这种方法实现的时间复杂度是O(N)，判断每个数据项是否大于temp变量、替换temp变量是常数操作，整个数组长度是N，因为遍历了整个数组，所有常数操作代价是C*N，所以时间复杂度是O(N)。


- example：在一个有序数组中寻找某个数据项

  ```php
  function findItem($array, $L, $R, $item){
      if($R <= $L){
          if($item == $array[$R])
              return $R;
          else
              return null;
      }
      
      $mid = ($L+$R)/2;
      if($item < $array[$mid]){
          return findItem($array, $L, $mid-1, $item);
      }else if($item > $array[$mid]){
          return findItem($array, $mid+1, $R, $item);
      }else{
          return $mid;
      }
  }

  function binarySearch($array, $item){
      return findItem($array, 0, count($array)-1, $item);
  }
  ```

  遍历整个数组来进行寻找，它的时间复杂度是O(N)；

  但是整个数组是有序的，每次将数组对半划分，如果中间数小于要查找的数，取左边的部分；如果中间数大于要查找的数，取右边的部分；按照这种方式一直划分下去直到无法划分或者找到该数字，利用划分的思想，如果数组长度是N，最多需要logN次查找，时间复杂度为O(logN)。


- 俩个有序数组的交集查找

  如果取出A数组中的每个数据项去B数组中查找，需要进行N*N次查找，时间复杂度是N^2




#### 空间复杂度

一般说空间复杂度指的是额外空间复杂度，输入和输出的数据结构是不算在额外空间中的。

为了支持算法的流程需要使用多少辅助空间才能完成该算法的空间叫做额外空间，也就是所说的空间复杂度。

- 案例分析

  问题：有一个数组是1,2,3,5,7，左半区是1,2,3，右边区是5,7，要求交换左右俩个区间的数据，交换后的结果为5,7,1,2,3.

  正常解：按照正常的做法申请俩个区间大小的数组，分别存储左右区间的数据，先输出右边区的数据，再输出左半区的数据，因为开辟了N个长度的数据空间，所以该方法的空间复杂度是O(N)；

  优解：先交换左半区的数据，再交换右半区的数据，最后交换整个数组的数据项，该解法的额外空间复杂度是O(1)，时间复杂度是O(N)



#### 算法的最优解

一个算法的最优解指的是先满足时间复杂度最优的情况下，再满足空间复杂度最优解。



#### 冒泡排序

```php
function BubbleSort($array){
    if(empty($array))
        return false;

    $length = count($array);
    for($i=$length-2; $i>=0; $i--){
        for($j=0; $j<=$i; $j++){
            if($array[$j] > $array[$j+1]){
                swap($array, $j, $j+1);
            }
        }
    }

    return $array;
}

function swap(&$array, $l, $r){
    $temp = $array[$l];
    $array[$l] = $array[$r];
    $array[$r] = $temp;
}
```

俩俩比较俩个数据项，如果左边的数据项大于右边的数据项则交换俩个数据项，遍历整个数组后将会把数组中最大的数据项交换到数组尾部，再俩俩比较剩余的数据项，重复此过程直到数组有序。

时间复杂度是O(N^2)，额外空间复杂度是O(1)，实现可以做到稳定性。



#### 选择排序

遍历整个数组选出最小的数据项放在数组第一位索引上，之后遍历剩余的数据项选出最小的数据项放在数组第二位索引上，重复此过程直到数组有序。

例如有数组：A、B、C、D、E，需要在以下数据项中查找最小的数据项：

- A、B、C、D、E    => N
- B、C、D、E          => N-1
- C、D、E                => 3
- D、E                      => 2

常数操作有2+3+...+(N-1)+N，这是一个等差数列，所以时间复杂度是O(N^2)，额外空间复杂度是O(1)



#### 插入排序

插入排序是将一个无序的数组插入到一个有序数组中的过程。

假设数组：A/B/C/D/E，将A数据项抽出来假定为一个有序的临时数组(只有一个数据项，肯定是有序的)，将剩下的数据项分别正确插入到有序的临时数组中。

比较插入的步骤有：

- B与A比较
- C与A/B比较
- D与A/B/C比较
- E与A/B/C/E比较

在最好情况下时间复杂度为O(N)，最坏情况下是O(N^2)，平均情况下时间复杂度也是O(N^2)



#### 递归

递归是把一个大规模的问题分解成若干个小规模问题来进行处理，无论是处理大规模还是处理小规模，处理问题的方法是一致的。

在代码上的表现是自己调用自己，实际工程是使用系统栈来实现的，每次发生递归时会将当前代码环境以及相关变量压入栈中，一次递归结束则出栈。



#### master公式

```
如果一个算法的时间复杂度公式为：T(n) = aT(n/b) + O(N^d)，
即样本量是b分之n的情况下，发生了a次调用，除出递归行为剩下的复杂度是big o N的d次方，
对于这种公式，master公式可以直接计算出复杂度。
```



#### 归并排序

归并排序是一个划分的过程，假设有N个数据项，有函数f(N)，将其划分为f(0-N/2)和f(N/2-N)俩个部分进行内排序，再将俩部分有序的数据项进行合并。

具体递归过程中是从顶向下进行划分，在数据项只有一个时则停止，再从底向上过程中进行合并。

- 复杂度分析

  将N个数据项对半的划分这个过程是可以抽象成一棵树的，每次对半划分将有俩个节点，这里的节点并不是具体的数据，而是内排序的一个流程。

  那么这棵树的高度是logN+1，节点数是2N-1个节点；LogN+1的1是最后一层树的叶子节点，即递归的basecase，也就是只剩下一个数据项时停止递归。

  由于有LogN+1层节点，每层节点在外排序合并的过程中进行了N次比较，所以时间复杂度是logN^2，又因为在合并过程中每层节点申请了N个数组长度的空间，所以额外空间复杂度是logN^2。

  结论：时间复杂度是O(logN^2)，额外空间复杂度是O(logN^2)。



