#### 算法

有一个数据源，该数据源的结构叫做数据结构。在这个数据结构基础上实现一个功能所设计的流程就叫做算法。



#### 时间复杂度

- 时间复杂度

  时间复杂度是一个算法流程中常数操作数量的指标，该指标叫做Big O，

  具体为常数操作数量的表达式中，只要高阶项，不要低阶项，也不要高阶项系数之后剩下的部分记为f(N)，

  那么该算法的时间复杂度是O(f(N))

- 常数操作

  指计算机完成一个操作的时间与数据量等等额外因素无关，它是一个固定的代价，一般记为C。

  例如在数组中获取一个数据项，它的时间是一个常数，称为O(1)


- example：寻找一个数组中最大的数据项

  ```php
  function findMax($array){
      $temp = $array[0];
      $length = count($array);
      
      for($i=0; $i<$length; $i++){
          if($temp < $array[$i]){
              $temp = $array[$i];
          }
      }
      return $tmep;
  }
  ```

  在一个数组中寻找最大的数据项，简单的方法是用一个变量存储最大值，遍历整个数组，只要发现有数据项大于该变量就更新该变量的最大值。

  这种方法实现的时间复杂度是O(N)，判断每个数据项是否大于temp变量、替换temp变量是常数操作，整个数组长度是N，因为遍历了整个数组，所有常数操作代价是C*N，所以时间复杂度是O(N)。


- example：在一个有序数组中寻找某个数据项

  ```php
  function findItem($array, $L, $R, $item){
      if($R <= $L){
          if($item == $array[$R])
              return $R;
          else
              return null;
      }
      
      $mid = ($L+$R)/2;
      if($item < $array[$mid]){
          return findItem($array, $L, $mid-1, $item);
      }else if($item > $array[$mid]){
          return findItem($array, $mid+1, $R, $item);
      }else{
          return $mid;
      }
  }

  function binarySearch($array, $item){
      return findItem($array, 0, count($array)-1, $item);
  }
  ```

  遍历整个数组来进行寻找，它的时间复杂度是O(N)；

  但是整个数组是有序的，每次将数组对半划分，如果中间数小于要查找的数，取左边的部分；如果中间数大于要查找的数，取右边的部分；按照这种方式一直划分下去直到无法划分或者找到该数字，利用划分的思想，如果数组长度是N，最多需要logN次查找，时间复杂度为O(logN)。


- 俩个有序数组的交集查找

  解1：如果取出A数组中的每个数据项去B数组中查找，需要进行N*N次查找，时间复杂度是N^2；

  解2：由于数组都是有序的，可以使用二分查找去查找数据项，时间复杂度是N*logM；

  解3：由于数组都是有序的，分别使用A、B俩个指针指向俩个数组的起始索引，比较指针指向的数据项，对于小的数据项的指针则向前移动，如果俩个数据项相等则俩个指针同时移动；按照这种方式进行比较直到某个指针越界，时间复杂度是O(M+N)

  ```php
  //在俩个有序的数组中寻找交集的部分
  function Intersection($array1, $array2){
      $leftLength = count($array1);
      $rightLength = count($array2);

      $leftPoint = 0;
      $rightPoint = 0;

      $same = array();

      while($leftPoint < $leftLength && $rightPoint < $rightLength){
          if($array1[$leftPoint] < $array2[$rightPoint]){
              $leftPoint++;
          }else if($array1[$leftPoint] > $array2[$rightPoint]){
              $rightPoint++;
          }else{
              $same[] = $array1[$leftPoint];

              $leftPoint++;
              $rightPoint++;
          }
      }

      return $same;
  }
  ```




#### 空间复杂度

一般说空间复杂度指的是额外空间复杂度，输入和输出的数据结构是不算在额外空间中的。

为了支持算法的流程需要使用多少辅助空间才能完成该算法的空间叫做额外空间，也就是所说的空间复杂度。

- 案例分析

  问题：有一个数组是1,2,3,5,7，左半区是1,2,3，右边区是5,7，要求交换左右俩个区间的数据，交换后的结果为5,7,1,2,3.

  正常解：按照正常的做法申请俩个区间大小的数组，分别存储左右区间的数据，先输出右边区的数据，再输出左半区的数据，因为开辟了N个长度的数据空间，所以该方法的空间复杂度是O(N)；

  优解：先交换左半区的数据，再交换右半区的数据，最后交换整个数组的数据项，该解法的额外空间复杂度是O(1)，时间复杂度是O(N)


#### 算法的最优解

一个算法的最优解指的是先满足时间复杂度最优的情况下，再满足空间复杂度最优解。



#### 冒泡排序

```php
function BubbleSort($array){
    if(empty($array))
        return false;

    $length = count($array);
    for($i=$length-2; $i>=0; $i--){
        for($j=0; $j<=$i; $j++){
            if($array[$j] > $array[$j+1]){
                swap($array, $j, $j+1);
            }
        }
    }

    return $array;
}

function swap(&$array, $l, $r){
    $temp = $array[$l];
    $array[$l] = $array[$r];
    $array[$r] = $temp;
}
```

俩俩比较俩个数据项，如果左边的数据项大于右边的数据项则交换俩个数据项，遍历整个数组后将会把数组中最大的数据项交换到数组尾部，再俩俩比较剩余的数据项，重复此过程直到数组有序。

时间复杂度是O(N^2)，额外空间复杂度是O(1)，实现可以做到稳定性。



#### 选择排序

遍历整个数组选出最小的数据项放在数组第一位索引上，之后遍历剩余的数据项选出最小的数据项放在数组第二位索引上，重复此过程直到数组有序。

例如有数组：A、B、C、D、E，需要在以下数据项中查找最小的数据项：

- A、B、C、D、E    => N
- B、C、D、E          => N-1
- C、D、E                => 3
- D、E                      => 2

常数操作有2+3+...+(N-1)+N，这是一个等差数列，所以时间复杂度是O(N^2)，额外空间复杂度是O(1)



#### 插入排序

插入排序是将一个无序的数组插入到一个有序数组中的过程。

假设数组：A/B/C/D/E，将A数据项抽出来假定为一个有序的临时数组(只有一个数据项，肯定是有序的)，将剩下的数据项分别正确插入到有序的临时数组中。

比较插入的步骤有：

- B与A比较
- C与A/B比较
- D与A/B/C比较
- E与A/B/C/E比较

在最好情况下时间复杂度为O(N)，最坏情况下是O(N^2)，平均情况下时间复杂度也是O(N^2)



#### 递归

- 概念

  递归是把一个大规模的问题分解成若干个小规模问题来进行处理，无论是处理大规模还是处理小规模，处理问题的方法是一致的。


- 原理

  在代码上的表现是自己调用自己，实际工程是使用系统栈来实现的；

  父过程在发生递归时，会将父过程当前环境变量、发生递归的代码行数压入到栈中，然后执行子过程；如果子过程也发生了递归调用，同理也会将子过程相关变量压入栈中；这样在子问题碰到basecase时，将会从栈中弹出当时子过程发生递归的场景，方便回溯到父过程。

- basecase

  在将问题划分成子问题时，当子问题达到一个规模时将停止划分。



#### 归并排序

归并排序是一个划分的过程，假设有N个数据项，有函数f(N)，将其划分为f(0-N/2)和f(N/2-N)俩个部分进行内排序，再将俩部分有序的数据项进行合并。

具体递归过程中是从顶向下进行划分，在数据项只有一个时则停止，再从底向上过程中进行合并。

- 时间复杂度

  将复杂度抽象成$T(N)$，递归的对半划分会产生$T(N/2)$俩个规模的节点(子问题)，一直对半的划分下去直到该规模为1时停止划分。

  如果将其抽象成一棵树，树的高度是$logN+1$，节点数（子问题数量）是$2N-1$，每层节点在合并排序过程中进行N次常数操作的比较，所以时间复杂度是$N*logN$。

  已知树的高度是logN+1，节点数（子问题数量）是2N-1，每层节点在合并排序过程中进行N次常数操作的比较，所以时间复杂度是N*logN。

  注：+1是树的最后一层，即递归的basecase，所以最后一层有N个节点。

- 空间复杂度

  在外排序合并数据项的代价是N，空间复杂度是$O(N)$


#### master公式

如果一个算法的时间复杂度公式为：
$$
T(n) = aT(n/b) + O(N^d)
$$
即样本量是b分之n的情况下，发生了a次调用，除去递归行为剩下的复杂度是$O(N)$的d次方，对于这种公式，master公式可以直接计算出复杂度。

具体有3种情况：

- $log_{b}a>b$ ，时间复杂度是$O(N^{log_{b}a})$
- $d>log_{b}a$，时间复杂度是$O(N^{d})$
- $d=log_{b}a$，时间复杂度是$O(N^{d} * logN)$



案例：归并排序时间复杂度分析

空间如果整个算法复杂度是$T(N)$，N是样本量，在实现中将问题划对半的划分成俩个部分来解决，所以左部分的时间复杂度是$T(N/2)$，右部分时间复杂度是$T(N/2)$，同时在合并这俩个部分的时间复杂度是$O(N)$，得到公式：
$$
T(N) = 2T(N/2) + O(N)
$$
a=2，b=2，d=1，代入公式$log_ba$是$log_22$的值是1，所以是第三种情况，时间复杂度是$logN*N$。



#### 快速排序



- 时间复杂度
- 空间复杂度