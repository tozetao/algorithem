#### 算法

有一个数据源，该数据源的结构叫做数据结构。在这个数据结构基础上实现一个功能所设计的流程就叫做算法。



#### 时间复杂度

- 时间复杂度

  时间复杂度是一个算法流程中常数操作数量的指标，该指标叫做Big O，

  具体为常数操作数量的表达式中，只要高阶项，不要低阶项，也不要高阶项系数之后剩下的部分记为$f(N)$，那么该算法的时间复杂度是$O(f(N))$

- 常数操作

  指计算机完成一个操作的时间与数据量等等额外因素无关，它是一个固定的代价，一般记为C。

  例如在数组中获取一个数据项，它的时间是一个常数，称为$O(1)$


- example：寻找一个数组中最大的数据项

  ```php
  function findMax($array){
      $temp = $array[0];
      $length = count($array);
      
      for($i=0; $i<$length; $i++){
          if($temp < $array[$i]){
              $temp = $array[$i];
          }
      }
      return $tmep;
  }
  ```

  在一个数组中寻找最大的数据项，简单的方法是用一个变量存储最大值，遍历整个数组，只要发现有数据项大于该变量就更新该变量的最大值。

  这种方法实现的时间复杂度是$O(N)$，判断每个数据项是否大于temp变量、替换temp变量是常数操作，整个数组长度是N，因为遍历了整个数组，所有常数操作代价是$C*N$，所以时间复杂度是$O(N)$。


- example：在一个有序数组中寻找某个数据项

  ```php
  function findItem($array, $L, $R, $item){
      if($R <= $L){
          if($item == $array[$R])
              return $R;
          else
              return null;
      }
      
      $mid = ($L+$R)/2;
      if($item < $array[$mid]){
          return findItem($array, $L, $mid-1, $item);
      }else if($item > $array[$mid]){
          return findItem($array, $mid+1, $R, $item);
      }else{
          return $mid;
      }
  }

  function binarySearch($array, $item){
      return findItem($array, 0, count($array)-1, $item);
  }
  ```

  遍历整个数组来进行寻找，它的时间复杂度是$O(N)$；

  但是整个数组是有序的，每次将数组对半划分，如果中间数小于要查找的数，取左边的部分；如果中间数大于要查找的数，取右边的部分；按照这种方式一直划分下去直到无法划分或者找到该数字，利用划分的思想，如果数组长度是N，最多需要$logN$次查找，时间复杂度为$O(logN)$。


- 俩个有序数组的交集查找

  解1：如果取出A数组中的每个数据项去B数组中查找，需要进行N*N次查找，时间复杂度是$O(N^2)$；

  解2：由于数组都是有序的，可以使用二分查找去查找数据项，时间复杂度是$N*logM$；

  解3：由于数组都是有序的，分别使用A、B俩个指针指向俩个数组的起始索引，比较指针指向的数据项，对于小的数据项的指针则向前移动，如果俩个数据项相等则俩个指针同时移动；按照这种方式进行比较直到某个指针越界，时间复杂度是$O(M+N)$

  ```php
  //在俩个有序的数组中寻找交集的部分
  function Intersection($array1, $array2){
      $leftLength = count($array1);
      $rightLength = count($array2);

      $leftPoint = 0;
      $rightPoint = 0;

      $same = array();

      while($leftPoint < $leftLength && $rightPoint < $rightLength){
          if($array1[$leftPoint] < $array2[$rightPoint]){
              $leftPoint++;
          }else if($array1[$leftPoint] > $array2[$rightPoint]){
              $rightPoint++;
          }else{
              $same[] = $array1[$leftPoint];

              $leftPoint++;
              $rightPoint++;
          }
      }

      return $same;
  }
  ```




#### 空间复杂度

一般说空间复杂度指的是额外空间复杂度，输入和输出的数据结构是不算在额外空间中的。

为了支持算法的流程需要使用多少辅助空间才能完成该算法的空间叫做额外空间，也就是所说的空间复杂度。

- 案例分析

  问题：有一个数组是1,2,3,5,7，左半区是1,2,3，右边区是5,7，要求交换左右俩个区间的数据，交换后的结果为5,7,1,2,3.

  正常解：按照正常的做法申请俩个区间大小的数组，分别存储左右区间的数据，先输出右边区的数据，再输出左半区的数据，因为开辟了N个长度的数据空间，所以该方法的空间复杂度是O(N)；

  优解：先交换左半区的数据，再交换右半区的数据，最后交换整个数组的数据项，该解法的额外空间复杂度是$O(1)$，时间复杂度是$O(N)$


#### 算法的最优解

一个算法的最优解指的是先满足时间复杂度最优的情况下，再满足空间复杂度最优解。



#### 冒泡排序

```php
function BubbleSort($array){
    if(empty($array))
        return false;

    $length = count($array);
    for($i=$length-2; $i>=0; $i--){
        for($j=0; $j<=$i; $j++){
            if($array[$j] > $array[$j+1]){
                swap($array, $j, $j+1);
            }
        }
    }

    return $array;
}

function swap(&$array, $l, $r){
    $temp = $array[$l];
    $array[$l] = $array[$r];
    $array[$r] = $temp;
}
```

俩俩比较俩个数据项，如果左边的数据项大于右边的数据项则交换俩个数据项，遍历整个数组后将会把数组中最大的数据项交换到数组尾部，再俩俩比较剩余的数据项，重复此过程直到数组有序。

时间复杂度是$O(N^2)$，额外空间复杂度是$O(1)$，实现可以做到稳定性。



#### 选择排序

遍历整个数组选出最小的数据项放在数组第一位索引上，之后遍历剩余的数据项选出最小的数据项放在数组第二位索引上，重复此过程直到数组有序。

例如有数组：A、B、C、D、E，需要在以下数据项中查找最小的数据项：

- A、B、C、D、E    => N
- B、C、D、E          => N-1
- C、D、E                => 3
- D、E                      => 2

常数操作有2+3+...+(N-1)+N，这是一个等差数列，所以时间复杂度是$O(N^2)$，额外空间复杂度是$O(1)$



#### 插入排序

插入排序是将一个无序的数组插入到一个有序数组中的过程。

假设数组：A/B/C/D/E，将A数据项抽出来假定为一个有序的临时数组(只有一个数据项，肯定是有序的)，将剩下的数据项分别正确插入到有序的临时数组中。

比较插入的步骤有：

- B与A比较
- C与A/B比较
- D与A/B/C比较
- E与A/B/C/E比较

在最好情况下时间复杂度为$O(N)$，最坏情况下是$O(N^2)$，平均情况下时间复杂度也是$O(N^2)$

#### 递归

- 概念

  递归是把一个大规模的问题分解成若干个小规模问题来进行处理，无论是处理大规模还是处理小规模，处理问题的方法是一致的。


- 原理

  在代码上的表现是自己调用自己，实际工程是使用系统栈来实现的；

  父过程在发生递归时，会将父过程当前环境变量、发生递归的代码行数压入到栈中，然后执行子过程；如果子过程也发生了递归调用，同理也会将子过程相关变量压入栈中；这样在子问题碰到basecase时，将会从栈中弹出当时子过程发生递归的场景，方便回溯到父过程。

- basecase

  在将问题划分成子问题时，当子问题达到一个规模时将停止划分。



#### 归并排序

归并排序是一个划分的过程，假设有N个数据项，有函数$f(N)$，将其划分为$f(0-N/2)$和$f(N/2+1-N)$俩个部分进行内排序，再将俩部分有序的数据项进行合并。

具体递归过程中是从顶向下进行划分，在数据项只有一个时则停止，再从底向上过程中进行合并。

- 时间复杂度

  将复杂度抽象成$T(N)$，递归的对半划分会产生$T(N/2)$俩个规模的节点(子问题)，一直对半的划分下去直到该规模为1时停止划分。

  如果将其抽象成一棵树，树的高度是$logN+1$，节点数（子问题数量）是$2N-1$，每层节点在合并排序过程中进行N次常数操作的比较，所以时间复杂度是$N*logN$。

  已知树的高度是$logN+1$，节点数（子问题数量）是$2N-1$，每层节点在合并排序过程中进行N次常数操作的比较，所以时间复杂度是$N*logN$。

  注：+1是树的最后一层，即递归的basecase，所以最后一层有N个节点。

- 空间复杂度

  在外排序过程中，将俩部分数据项合并为一个有序的数组，代码申请了一个长度N的辅助数组，

  所以空间复杂度是$O(N)$


#### master公式

如果一个算法的时间复杂度公式为：
$$
T(n) = aT(n/b) + O(N^d)
$$
即样本量是b分之n的情况下，发生了a次调用，除去递归行为剩下的复杂度是$O(N)$的d次方，对于这种公式，master公式可以直接计算出复杂度。

具体有3种情况：

- $log_{b}a>b$ ，时间复杂度是$O(N^{log_{b}a})$
- $d>log_{b}a$，时间复杂度是$O(N^{d})$
- $d=log_{b}a$，时间复杂度是$O(N^{d} * logN)$



案例：归并排序时间复杂度分析

空间如果整个算法复杂度是$T(N)$，N是样本量，在实现中将问题划对半的划分成俩个部分来解决，所以左部分的时间复杂度是$T(N/2)$，右部分时间复杂度是$T(N/2)$，同时在合并这俩个部分的时间复杂度是$O(N)$，得到公式：
$$
T(N) = 2T(N/2) + O(N)
$$
a=2，b=2，d=1，代入公式$log_ba$是$log_22$的值是1，所以是第三种情况，时间复杂度是$logN*N$。



#### 快速排序

- 经典快速排序

  取数组中最后一个数据项作为划分值，小于等于划分值的数据项放到左边，大于划分值的数据项放到右边，使用划分值作为中间数将数组划分成俩部分，对剩下俩部分继续以上述方法进行数据项的划分，直到问题的规模无法划分为止。

  对一组数据项按照某个结果来划分数据项，该流程时间复杂度是$O(N)$，空间复杂度是$O(1)$


- 荷兰国旗问题

  在一个数组中，默认以最后一个数作为划分值，请将小于该数的数据项放到左边，等于的数据项放在中间，大于该数的数据项放到右边。

- 时间复杂度

  快排时间复杂度分为3种情况：分别是最好情况、最差情况以及长期期望。

  ​

  如果每次选取的划分值所划分的俩侧数据项很平均，那么快排的问题规模是：
  $$
  T(N) = 2T(N/2) + O(N)
  $$
  时间复杂度变为$O(lngN*N)$。

  ​

  如果每次选取的划分值划分的俩侧数据项个数不平均时，算法的代价就会变高。

  例如：1,2,3,4,5,6,7，如果每次选取最后一个数作为划分值，会导致算法经过N-1

  次的划分排序过程，第1次划分有N-1次比较，第2次划分N-2次比较，算法的过程是一个等差数列，时间复杂度是$O(N^2)$；

  ​

  所以快速排序在工程上选取划分数值时，会随机的去选择该数值，这样最差与最好情况的划分是一个概率的事件，通过概率来求一个总共概率的时间复杂度，是一个长期期望。

  常数项很低且长期期望的时间概率好，工程上表现很优秀。


- 空间复杂度

  空间复杂度是$O(logN)$。

  每次根据划分值划分数据项后，需要一个变量来保存划分区间，在由顶向下划分过程中需要该变量帮助程序向下划分，求的是一个深度值，假定理想情况下每次都是居中划分，所以时间复杂度认为是$O(logN)$

  与归并排序不同，归并排序是先由顶部到达底部，再由底部逐层向上排序，递归函数合并的过程中使用到N个长度的辅助使用，在结束递归后该空间就释放掉了，所以归并排序的空间复杂度是$O(N)$

L+(int)Math.random()*(R-L+1)





#### 完全二叉树

一棵树的每个节点都有左节点和右节点，并且每一层节点都是从左到右填满或者最底层的叶子节点是在填满的路上。

- 完全二叉树的高度是$logN$

#### 堆排序

堆是一个完全二叉树结构，落地结构是使用数组来实现。

如果父节点的数组索引是i，左节点是$2i+1$，右节点是$2i+2$；如果子节点的索引是i，父节点是$(i-1)/2$，值向下取整。

- 大根堆：树的根节点是最大的数据项且树中每个节点都大于它的子节点
- 小根堆：与大根堆相反

堆结构的API：

- heapInsert：节点向上比较的过程
- heapify：节点向下比较的过程



- 时间复杂度

节点向上比较的过程，时间复杂度是$O(logN)$，节点向下比较的过程是$LogN$；

建立一个堆等于将每个数据项插入堆中，表达式有：
$$
log1+log2+...+logN = log(1+2+...+N) = log(N^2) = O(N)
$$
所以创建堆的时间复杂度是$O(N)$。

堆排序的复杂度是$O(N*logN)$，每次从堆顶取出一个数，需要与最后一个节点进行交换并做一次时间复杂度$logN$的heapify，所以时间复杂度是$O(N*logN)$

- 空间复杂度

  heapInsert与heapify的空间复杂度是O(1)



#### 排序稳定性

一个无序数组经过排序后，相同数据项的原有次序不会发生变化，这个是排序的稳定性。

例如数组...2...2...2，数组中有多个2，在经过排序后这些2的原有次序是不变的，这种排序就是稳定性的排序。

#### 对数器

