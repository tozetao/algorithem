### 树
树是不包含回路的连同无向图，因为树不包含回路，所以有以下特点：

- 一棵树中的任意俩个节点有且仅有唯一的一条路径通道
- 一棵树如果有n个节点，那么它一定有n-1条边




### 节点的类型

- 根节点：最顶端的节点，没有父节点
- 叶子节点：最底部的节点，没有子节点
- 内部节点：即有父节点也有子节点的节点




### 二叉树
一种特殊的树，每个节点有左节点和右节点，或者说只有每个节点最多有俩个子树。
二叉树还有2种特殊类型的树，分别是满二叉树和完全二叉树。

- 满二叉树：一颗深度为h并且有$2^h-1$个节点的树
- 完全二叉树：假设二叉树的高度为h层，除h层外，其他层的节点数都达到最大的个数，而第h层从右到左连续缺失若干节点，也就是说一个节点拥有右节点，那么它一定拥有左节点。
- 完全二叉树的高度是$logN$
- 完全二叉树的最后一个非叶子节点等于$n/2$，n是节点数




#### 二叉树的遍历

- 先序遍历

  先中，再左，再右；

  先打印中间节点，再打印左子树上所有节点，再打印右子树上所有节点，打印俩个子树时也遵循先中再左再右的原则。

- 中序遍历

  先左，再中，再右；对于每一个节点都是先打印左子树上的节点，再打印中间节点，再打印右子树上的节点。

- 后序遍历

  先左，再右，再中；对于每个节点都是先打印左子树上的节点，再打印右子树上的节点，最后打印中间节点。

时间复杂度分析

- 遍历二叉树无论是递归实现还是非递归实现，它的时间复杂度是$O(N)$，空间复杂度是$logN$，即树的高度。

中序遍历，非递归实现，核心思想是：将当前节点的左分支压入栈中，直到null为止；每弹出一个节点都会将弹出节点的右节点作为当前节点，并将它的左分支压入栈中；重复这个过程；



#### 后继节点

对一颗二叉树做中序遍历，在遍历序列结果中，每个节点相邻的后一个节点，就是该节点的后继节点；

如果通过遍历整棵树，根据遍历结果再去查询某个节点的后继节点，时间复杂度是$O(N)$；通过修改普通二叉树结构，给每一个节点增加一个指向其父节点的指针，查找节点的后继节点有更好的实现；

```php
class Node
{
    public $leftNode;
    public $rightNode;
    public $parent;
    public $val;
    
    public function __constructor($val)
    {
        $this->val = $val;
    }
}
```

通过该结构，假设有X节点，将会有3种情况：

- 如果X节点有右节点，右节点的最左子节点就是X的后继节点
- 如果X节点没有右子节点，X节点是其父节点的左子节点，那么父节点是X节点的后继节点
- 如果X节点没有右子节点，X节点是其父节点的右子节点，寻找将X节点所在的整颗子树作为左子树的节点，该节点就是X节点的后继节点；(以X节点向上寻找父节点，直到某个节点将子节点作为左子节点)、

### 堆

堆是一个完全二叉树结构，落地结构是使用数组来实现。

如果父节点的数组索引是i，左节点是$2i+1$，右节点是$2i+2$；如果子节点的索引是i，父节点是$(i-1)/2$，值向下取整。

- 大根堆：树的根节点是最大的数据项且树中每个节点都大于它的子节点
- 小根堆：与大根堆相反

堆结构的API：

- heapInsert：节点向上比较的过程

- heapify：节点向下比较的过程

- 时间复杂度

  节点向上比较的过程，时间复杂度是$O(logN)$，节点向下比较的过程是$LogN$；

  建立一个堆等于将每个数据项插入堆中，将$i$位置上的数插入堆中，$i-1$个数已经形成堆了，高度是$log(i-1)$，所以如果有N个数插入到堆中，堆高度的表达式有：$log1+log2+...+logN = O(N)$，所以创建堆的时间复杂度是$O(N)$。

  堆排序的复杂度是$O(N*logN)$，每次从堆顶取出一个数，需要与最后一个节点进行交换并做一次时间复杂度$logN$的heapify，所以时间复杂度是$O(N*logN)$


- 空间复杂度

  heapInsert与heapify的空间复杂度是O(1)



### 并查集

并查集是一个支持将俩个集合合并成一个集合，支持查询俩个集合是否同属一个集合的数据结构；

并查集的API

- isSameSet：查询俩个集合是否属于一个集合
- union：将俩个集合合并成一个大集合

集合的落地结构是由多个Node节点组成，Node对象有一个指向其代表节点的parent指针，也有一个当前集合大小的count变量；

```php
class Node
{
    Node parent;
    int count;
}
```

最开始每个集合都是最细粒度的，由一个Node对象组成的集合，并且parent指向自身，表示自己是该集合的代表点，且集合大小为1；

- 合并

  合并的时候遵循一个原则，将小的集合挂到大的集合下；例如有A、B俩个集合，A集合大小为1，B集合大小为2，那么将A集合的代表节点指向B集合的代表节点，即A集合挂到B集合下。


- 寻找一个集合的代表点

  通过parent指针向上寻找，如果parent指针指向当前节点，那么该节点是集合的代表节点；

  在寻找的过程中做一个打平的动作，即将沿途的节点都指向代表节点，减少集合的路径长度。这是一个很重要的操作，降低算法时间复杂度。

时间复杂度

​	如果有n个元素，查询的次数+合并的次数，如果次数逼近O(N)或以上，单次查询和单次合并，它的时间复杂度平均O(1)，是所有查询和合并的平均代价是O(1)





### Morris遍历

递归遍历和非递归遍历二叉树的时间复杂度是$O(N)$，空间复杂度是$O(h)$，即二叉树的高度；

Morris遍历也是遍历二叉树的一种方法，但是它的空间复杂度是O(1)，遍历过程如下：

- 设定root节点为当前节点(current)

- current节点没有左子树，current向右移动

- current节点有左子树，找到current节点左子树的最右节点(mostRight)；

  如果mostRight的右孩子为null，则有孩子指向current，然后current向左移动；

  如果mostRight的右孩子指向current，则current向右移动，同时将mostRight的右孩子置

Morris遍历概念

- Morris遍历是一种对于任何一个有左子树的节点俩次回到自己，对于没有左子树的节点只到达这个节点一次的遍历，同时整体遍历顺序是先中间节点，再遍历左子树最后遍历右子树的过程。

二叉树遍历的本质

- 二叉树的递归遍历如果没有打印函数，实际上是一种3次回到自己节点的一个过程；进入函数是第一次访问自己，递归完左子树后是第二次访问自己，递归完右子树是第三次回到自己。

  Morris遍历利用了递归这种特性，节点有左子树则回到自己俩次，第一和第二次是重合的，不会有第三次回到自己。次数的标记是利用左子树的最右节点指向当前节点的情况来标记是第一次访问当前节点还是第二次访问当前节点。

时间复杂度

- Morris遍历的时间复杂度是$O(N)$，额外空间复杂度是$O(1)$

